///
/// This file has been generated by bvtidl.pl. DO NOT MODIFY!
///

using System;
using System.Runtime.InteropServices;


namespace BVTSDK
{
/// <summary>
/// An ImageGenerator processes Ping data to create images.  
/// Thread-safety: none.
/// </summary>
    public class ImageGenerator : IDisposable
    {
        public ImageGenerator()
        {
            IntPtr p = NativeMethods.BVTImageGenerator_Create();
            _handle = new HandleRef(this, p);
        }

        internal ImageGenerator(IntPtr p)
        {
            _handle = new HandleRef(this, p);
        }

        /// Non-deterministic destruction of this object on the Finalizer thread
        ~ImageGenerator()
        {
            Dispose(false);
        }

        /// Dispose deterministically
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;
            _disposed = true;
            NativeMethods.BVTImageGenerator_Destroy(_handle);
        }

        /// <summary>
        /// Set the Head and perform expensive initialization.
        /// @see IsValidForHead
        /// </summary>
        /// <param name="head">The Head from which subsequent pings will be passed </param>     
        public void SetHead(Head head)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_SetHead(_handle, head.Handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return true if the specified Head is associated with this instance. If false, you must
        /// call SetHead.
        /// @see SetHead
        /// </summary>
        /// <param name="head">The Head to check </param>
        /// <returns>True if the specified Head is valid for this instance. </returns>      
        public bool IsValidForHead(Head head)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int is_valid;
            int error_code = NativeMethods.BVTImageGenerator_IsValidForHead(_handle, head.Handle, out is_valid);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            return is_valid > 0;
        }

        /// <summary>
        /// Set the image processing resolution. The RES_AUTO setting is highly
        /// recommended, as it adapts via a formula according to the stop range,
        /// whereas the other ranges are fixed values, and should only be used
        /// in specialized cases, such as requesting high resolution for longer
        /// distances (which will increase the processing time required to 
        /// create the image). R-Theta images may use either this function or
        /// SetRangeResolution(), depending on the degree of control required.
        /// </summary>
        /// <param name="resolutionPolicy">Resolution constant (IMAGERES_*)</param>     
        public void SetImageResolutionPolicy(ImageRes resolutionPolicy)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_SetImageResolutionPolicy(_handle, ((int) resolutionPolicy));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the algorithm used to calculate image resolution.
        /// </summary>
        /// <returns>Resolution constant (IMAGERES_*) </returns>        
        public ImageRes ImageResolutionPolicy
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
                int resolutionPolicy;
                int error_code = NativeMethods.BVTImageGenerator_GetImageResolutionPolicy(_handle, out resolutionPolicy);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return (ImageRes) resolutionPolicy;
            }
        }

        /// <summary>
        /// Return the filter flags.  As of this version, if more than one flag is set, only the lowest-valued flag is used.
        /// </summary>
        /// <returns>The image filter flags in use. (Bit field) </returns>      
        public ImageFilterFlags ImageFilterFlags
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
                int flags;
                int error_code = NativeMethods.BVTImageGenerator_GetImageFilterFlags(_handle, out flags);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return (ImageFilterFlags) flags;
            }
        }

        /// <summary>
        /// Set the filter flags. As of this version, if more than one flag is set, only the lowest-valued flag is used.
        /// </summary>
        /// <param name="flags">Image filter flags to use (bit field) </param>      
        public void SetImageFilterFlags(ImageFilterFlags flags)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_SetImageFilterFlags(_handle, ((int) flags));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// @see SetRangeResolution
        /// </summary>
        /// <returns>Range resolution, in meters </returns>     
        public float RangeResolution
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
                float resolution_in_meters;
                int error_code = NativeMethods.BVTImageGenerator_GetRangeResolution(_handle, out resolution_in_meters);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return resolution_in_meters;
            }
        }

        /// <summary>
        /// Requests a range resolution for R-Theta images. Also affects the
        /// range resolution for RangeProfile. Note that the exact range resolution
        /// may not be available, and the closest resolution will be set. The
        /// actual resolution can be obtained by querying the returned image
        /// or RangeProfile object.
        /// </summary>
        /// <param name="resolution_in_meters">Range resolution, in meters </param>     
        public void SetRangeResolution(float resolution_in_meters)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_SetRangeResolution(_handle, resolution_in_meters);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// @see BVTHead_SetRangeProfileThreshold
        /// </summary>
        /// <returns>minimum detection threshold </returns>     
        public UInt16 RangeProfileIntensityThreshold
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
                UInt16 threshold;
                int error_code = NativeMethods.BVTImageGenerator_GetRangeProfileIntensityThreshold(_handle, out threshold);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return threshold;
            }
        }

        /// <summary>
        /// @see BVTHead_SetRangeProfileThreshold
        /// </summary>
        /// <param name="threshold">minimum detection threshold </param>        
        public void SetRangeProfileIntensityThreshold(UInt16 threshold)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_SetRangeProfileIntensityThreshold(_handle, threshold);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// @see BVTHead_SetTargetStartRange
        /// </summary>
        /// <returns>minimum range to detect </returns>     
        public float RangeProfileStartRange
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
                float start_range;
                int error_code = NativeMethods.BVTImageGenerator_GetRangeProfileStartRange(_handle, out start_range);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return start_range;
            }
        }

        /// <summary>
        /// @see BVTHead_SetTargetStartRange
        /// </summary>
        /// <param name="start_range">minimum detection to detect </param>      
        public void SetRangeProfileStartRange(float start_range)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_SetRangeProfileStartRange(_handle, start_range);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Set the preferred XY image size. Note that the aspect ratio of the image
        /// remains fixed (as a function of start and stop range). If you specify non-zero 
        /// parameters to this method that violate the aspect ratio, the image width will be 
        /// adjusted.
        /// This is a helper function to accompany the GetImageXY() function.
        /// </summary>
        /// <param name="width">The requested width, or 0 for no change </param>
        /// <param name="height">The requested height, or 0 for no change </param>      
        public void SetXYImageSize(int width, int height)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_SetXYImageSize(_handle, width, height);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Set the RTheta image width
        /// This is a helper function to accompany the GetImageRTheta() function.
        /// </summary>
        /// <param name="width">The requested width </param>        
        public void SetRThetaImageWidth(int width)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_SetRThetaImageWidth(_handle, width);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Get the RTheta image width
        /// This is a helper function to accompany the GetImageRTheta() function.
        /// </summary>
        /// <returns>The requested width </returns>     
        public int RThetaImageWidth
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
                int width;
                int error_code = NativeMethods.BVTImageGenerator_GetRThetaImageWidth(_handle, out width);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return width;
            }
        }

        /// <summary>
        /// Retrieve an XY-format image of this ping, according to the parameters set
        /// in the head used to get this ping. Use BVTHead_SetImageSizeXY() to set the size for this image.
        /// See Head and MagImage documentation for more details.
        /// </summary>
        /// <param name="ping">The Ping to generate image from. </param>
        /// <returns>Output XY image </returns>     
        public MagImage GetImageXY(Ping ping)
        {
            IntPtr img_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_GetImageXY(_handle, ping.Handle, ref img_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            MagImage img = new MagImage(img_ptr);
            return img;
        }

        /// <summary>
        /// Retrieve an R-Theta format image of this ping, according to the parameters set
        /// in the head used to get this ping. Use BVTHead_SetImageWidthRTheta() to set the size for this image.
        /// See Head and MagImage documentation for more details.
        /// </summary>
        /// <param name="ping">The Ping to generate image from. </param>
        /// <returns>Output R-Theta image </returns>        
        public MagImage GetImageRTheta(Ping ping)
        {
            IntPtr img_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_GetImageRTheta(_handle, ping.Handle, ref img_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            MagImage img = new MagImage(img_ptr);
            return img;
        }

        /// <summary>
        /// Creates and returns RangeProfile for the ping.
        /// @warning This function will fail on a sonar with old firmware, or a file recorded from a sonar with old firmware.
        /// </summary>
        /// <param name="ping">The Ping to generate image from. </param>
        /// <returns>The created RangeProfile </returns>        
        public RangeProfile GetRangeProfile(Ping ping)
        {
            IntPtr ranges_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_GetRangeProfile(_handle, ping.Handle, ref ranges_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            RangeProfile ranges = new RangeProfile(ranges_ptr);
            return ranges;
        }

        /// <summary>
        /// Returns the RangeProfile for a ping with RangeProfile created on the sonar, not the client.
        /// @note Returns an error if this ping does not have a stored RangeProfile.
        /// </summary>
        /// <param name="ping">The Ping to generate image from. </param>
        /// <returns>The created RangeProfile </returns>        
        public RangeProfile GetStoredRangeProfile(Ping ping)
        {
            IntPtr ranges_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_GetStoredRangeProfile(_handle, ping.Handle, ref ranges_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            RangeProfile ranges = new RangeProfile(ranges_ptr);
            return ranges;
        }

        /// <summary>
        /// The clipping threshold specifies the percentage of dynamic range above which data will be nulled. 
        /// The value must be set between 0.0 and 1.0. A value of 0.0 indicates 
        /// that all data should be nulled (everything clips), while a value of 1.0 effectively 
        /// disables any high-side thresholding. Clipped data is not processed, saving CPU cycles, 
        /// so the clipping threshold may serve as a performance tuning parameter.
        /// </summary>
        /// <param name="threshold">The upper bound threshold as a percentage of dynamic range for valid data from the A/D </param>     
        public void SetClippingThreshold(float threshold)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_SetClippingThreshold(_handle, threshold);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the floating point value of the clipping threshold. 
        /// This threshold represents a percentage of dynamic range above which data is considered 
        /// clipped and subsequently nulled. 
        /// </summary>
        /// <returns>Lower bound threshold value from 0 to 1 </returns>     
        public float ClippingThreshold
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
                float threshold;
                int error_code = NativeMethods.BVTImageGenerator_GetClippingThreshold(_handle, out threshold);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return threshold;
            }
        }

        /// <summary>
        /// The noise threshold specifies the percentage of dynamic range below which data will be nulled. 
        /// The value must be set between 0.0 and 1.0. A value of 0.0 indicates that no data should be nulled, 
        /// effectively disabling low-side thresholding, while a value of 1.0 will force all data to be nulled. 
        /// Data that is not above the noise threshold is not processed, saving CPU cycles, so the noise 
        /// threshold may serve as a performance tuning parameter.
        /// </summary>
        /// <param name="threshold">The lower bound threshold as a percentage of dynamic range for valid data from the A/D </param>     
        public void SetNoiseThreshold(float threshold)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_SetNoiseThreshold(_handle, threshold);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the floating point value of the noise threshold. This threshold 
        /// represents a percentage of dynamic range below which data is considered 
        /// to be noise and subsequently nulled.
        /// </summary>
        /// <returns>The noise threshold in use. </returns>     
        public float NoiseThreshold
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
                float threshold;
                int error_code = NativeMethods.BVTImageGenerator_GetNoiseThreshold(_handle, out threshold);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return threshold;
            }
        }

        public const int SOUND_SPEED_OVERRIDE_OFF = 0;

        /// <summary>
        /// When the GetImage functions are called, ignore the sound speed stored in the ping and 
        /// use this value instead.  
        /// Use the default SOUND_SPEED_OVERRIDE_OFF to use the ping's stored sound speed.  
        /// </summary>
        /// <param name="meters_per_second">The sound speed in meters per second </param>       
        public void SetSoundSpeedOverride(int meters_per_second)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_SetSoundSpeedOverride(_handle, meters_per_second);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>The sound speed in meters per second </returns>        
        public int SoundSpeedOverride
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
                int meters_per_second;
                int error_code = NativeMethods.BVTImageGenerator_GetSoundSpeedOverride(_handle, out meters_per_second);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return meters_per_second;
            }
        }

        /// <summary>
        /// Do not use this. Experimental.
        /// </summary>
        /// <param name="algorithm">Undocumented. </param>      
        public void SetMapAlgorithm(int algorithm)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_SetMapAlgorithm(_handle, algorithm);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Do not use this. Experimental.
        /// </summary>
        /// <returns>Undocumented. </returns>       
        public int MapAlgorithm
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
                int algorithm;
                int error_code = NativeMethods.BVTImageGenerator_GetMapAlgorithm(_handle, out algorithm);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return algorithm;
            }
        }

        /// <summary>
        /// @warning This function will fail on a sonar with old firmware, or a file recorded from a sonar with old firmware.
        /// </summary>
        /// <param name="ping">The ping to modify. </param>     
        public void CreateStoredRangeProfileAndReplaceSignal(Ping ping)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_CreateStoredRangeProfileAndReplaceSignal(_handle, ping.Handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Retrieve the current overlap blending parameters.
        /// </summary>
        /// <param name="nearRangeBeamToFavor">Beam to favor at the sonar min range. 0 is highest freq., 128 is lowest freq. </param>
        /// <param name="farRangeBeamToFavor">Beam to favor at the sonar max range. </param>
        /// <param name="rangeSkewExponent">Controls the rate of change between nearRangeBeamToFavor and farRangeBeamToFavor w.r.t. pixel range, 0<e<1 ==> Move to far range beams quickly, 1<e<inf ==> Move to far range beams slowly </param>
        /// <param name="beamWeightExponent">Controls relative weights of beams close to and far from the beam to favor. e=0 ==> All beams weighted equally. As e increases, proximity to beam to favor becomes a greater factor in weighting </param>      
        public void GetSectorOverlapBlendingParams(out UInt32 nearRangeBeamToFavor, out UInt32 farRangeBeamToFavor, out float rangeSkewExponent, out float beamWeightExponent)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_GetSectorOverlapBlendingParams(_handle, out nearRangeBeamToFavor, out farRangeBeamToFavor, out rangeSkewExponent, out beamWeightExponent);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Set the overlap blending parameters. 
        /// </summary>
        /// <param name="nearRangeBeamToFavor">Beam to favor at the sonar min range. 0 is highest freq., 128 is lowest freq. </param>
        /// <param name="farRangeBeamToFavor">Beam to favor at the sonar max range. </param>
        /// <param name="rangeSkewExponent">Controls the rate of change between nearRangeBeamToFavor and farRangeBeamToFavor w.r.t.pixel range, 0<e<1 == > Move to far range beams quickly, 1<e<inf == > Move to far range beams slowly </param>
        /// <param name="beamWeightExponent">Controls relative weights of beams close to and far from the beam to favor.e = 0 == > All beams weighted equally.As e increases, proximity to beam to favor becomes a greater factor in weighting </param>     
        public void SetSectorOverlapBlendingParams(UInt32 nearRangeBeamToFavor, UInt32 farRangeBeamToFavor, float rangeSkewExponent, float beamWeightExponent)
        {
            if (_disposed) throw new ObjectDisposedException("BVTImageGenerator");
            int error_code = NativeMethods.BVTImageGenerator_SetSectorOverlapBlendingParams(_handle, nearRangeBeamToFavor, farRangeBeamToFavor, rangeSkewExponent, beamWeightExponent);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }


        /// SDK object pointer
        internal HandleRef Handle
        {
            get { return _handle; }
        }
        private readonly HandleRef _handle;

        private bool _disposed;

        /// P/Invoke 'wrapper' class
        private static class NativeMethods
        {
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern IntPtr BVTImageGenerator_Create();
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern IntPtr BVTImageGenerator_Destroy(HandleRef obj);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_SetHead(HandleRef obj, HandleRef head);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_IsValidForHead(HandleRef obj, HandleRef head, out int is_valid);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_SetImageResolutionPolicy(HandleRef obj, int resolutionPolicy);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetImageResolutionPolicy(HandleRef obj, out int resolutionPolicy);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetImageFilterFlags(HandleRef obj, out int flags);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_SetImageFilterFlags(HandleRef obj, int flags);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetRangeResolution(HandleRef obj, out float resolution_in_meters);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_SetRangeResolution(HandleRef obj, float resolution_in_meters);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetRangeProfileIntensityThreshold(HandleRef obj, out UInt16 threshold);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_SetRangeProfileIntensityThreshold(HandleRef obj, UInt16 threshold);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetRangeProfileStartRange(HandleRef obj, out float start_range);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_SetRangeProfileStartRange(HandleRef obj, float start_range);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_SetXYImageSize(HandleRef obj, int width, int height);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_SetRThetaImageWidth(HandleRef obj, int width);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetRThetaImageWidth(HandleRef obj, out int width);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetImageXY(HandleRef obj, HandleRef ping, ref IntPtr img);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetImageRTheta(HandleRef obj, HandleRef ping, ref IntPtr img);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetRangeProfile(HandleRef obj, HandleRef ping, ref IntPtr ranges);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetStoredRangeProfile(HandleRef obj, HandleRef ping, ref IntPtr ranges);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_SetClippingThreshold(HandleRef obj, float threshold);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetClippingThreshold(HandleRef obj, out float threshold);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_SetNoiseThreshold(HandleRef obj, float threshold);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetNoiseThreshold(HandleRef obj, out float threshold);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_SetSoundSpeedOverride(HandleRef obj, int meters_per_second);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetSoundSpeedOverride(HandleRef obj, out int meters_per_second);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_SetMapAlgorithm(HandleRef obj, int algorithm);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetMapAlgorithm(HandleRef obj, out int algorithm);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_CreateStoredRangeProfileAndReplaceSignal(HandleRef obj, HandleRef ping);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_GetSectorOverlapBlendingParams(HandleRef obj, out UInt32 nearRangeBeamToFavor, out UInt32 farRangeBeamToFavor, out float rangeSkewExponent, out float beamWeightExponent);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTImageGenerator_SetSectorOverlapBlendingParams(HandleRef obj, UInt32 nearRangeBeamToFavor, UInt32 farRangeBeamToFavor, float rangeSkewExponent, float beamWeightExponent);

        }
    }

}
