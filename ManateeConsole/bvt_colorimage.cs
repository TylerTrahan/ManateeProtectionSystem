///
/// This file has been generated by bvtidl.pl. DO NOT MODIFY!
///

using System;
using System.Runtime.InteropServices;


namespace BVTSDK
{
/// <summary>
/// Store a color image.  The API is nearly identical to MagImage.  The main difference is the 
/// pixel datatype. In ColorImage, each pixel is a single unsigned int. 
/// - Byte 0: Red Value
/// - Byte 1: Green Value
/// - Byte 2: Blue Value
/// - Byte 3: Alpha Value
/// </summary>
    public class ColorImage : IDisposable
    {
        public ColorImage()
        {
            IntPtr p = NativeMethods.BVTColorImage_Create();
            _handle = new HandleRef(this, p);
        }

        internal ColorImage(IntPtr p)
        {
            _handle = new HandleRef(this, p);
        }

        /// Non-deterministic destruction of this object on the Finalizer thread
        ~ColorImage()
        {
            Dispose(false);
        }

        /// Dispose deterministically
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;
            _disposed = true;
            NativeMethods.BVTColorImage_Destroy(_handle);
        }

        /// <summary>
        /// Return the value of the pixel at (row, col)
        /// </summary>
        /// <param name="row">Requested row </param>
        /// <param name="col">Requested col </param>
        /// <returns>Value of the pixel at (row, col) </returns>        
        public UInt32 GetPixel(int row, int col)
        {
            if (_disposed) throw new ObjectDisposedException("BVTColorImage");
            UInt32 pixel;
            int error_code = NativeMethods.BVTColorImage_GetPixel(_handle, row, col, out pixel);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            return pixel;
        }

        /// <summary>
        /// Set the value of the pixel at (row, col)
        /// </summary>
        /// <param name="row">Requested row </param>
        /// <param name="col">Requested col </param>
        /// <param name="pixel">Value of the pixel at (row, col) </param>       
        public void SetPixel(int row, int col, UInt32 pixel)
        {
            if (_disposed) throw new ObjectDisposedException("BVTColorImage");
            int error_code = NativeMethods.BVTColorImage_SetPixel(_handle, row, col, pixel);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Set the value of the pixel at (row, col)
        /// </summary>
        /// <param name="row">Requested row </param>
        /// <param name="col">Requested col </param>
        /// <param name="pixel">Value of the pixel at (row, col) </param>       
        public bool TrySetPixel(int row, int col, UInt32 pixel)
        {
            if (_disposed) throw new ObjectDisposedException("BVTColorImage");
            int error_code = NativeMethods.BVTColorImage_SetPixel(_handle, row, col, pixel);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                return false;
            }
            return true;
        }

        /// <summary>
        /// Return a pointer to a row of pixels 
        /// </summary>
        /// <param name="row">Requested row index </param>
        /// <returns>pointer to pointer to row</returns>        
        public UInt32 GetRow(int row)
        {
            if (_disposed) throw new ObjectDisposedException("BVTColorImage");
            UInt32 rowPointer;
            int error_code = NativeMethods.BVTColorImage_GetRow(_handle, row, out rowPointer);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            return rowPointer;
        }

        /// <summary>
        /// Return a pointer to the entire image.
        /// The image or organized in Row-Major order (just like C/C++).
        /// </summary>
        /// <returns>pointer to pointer to image </returns>     
        public UInt32 Bits
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTColorImage");
                UInt32 bitsPointer;
                int error_code = NativeMethods.BVTColorImage_GetBits(_handle, out bitsPointer);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return bitsPointer;
            }
        }

        /// <summary>
        /// Copy the raw image data to the user specified buffer. See Bits for more info.
        /// </summary>
        /// <param name="data">Pointer to a valid buffer </param>
        /// <param name="len">The size of the buffer pointed to by data in pixels NOT bytes. </param>       
        public void CopyBits(UInt32[] data, UInt32 len)
        {
            if (_disposed) throw new ObjectDisposedException("BVTColorImage");
            int error_code = NativeMethods.BVTColorImage_CopyBits(_handle, data, len);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the number of boundaries for this image. A boundary defines
        /// the limit of data for a transducer, and is always a line.
        /// </summary>
        /// <returns>The number of boundaries defined for this  image. </returns>       
        public int BoundaryCount
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTColorImage");
                int count;
                int error_code = NativeMethods.BVTColorImage_GetBoundaryCount(_handle, out count);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return count;
            }
        }

        /// <summary>
        /// Get the true line segment for the boundary at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the boundary. </param>
        /// <param name="x0">The near x-coordinate in meters. </param>
        /// <param name="y0">The near y-coordinate in meters. </param>
        /// <param name="x1">The far x-coordinate in meters. </param>
        /// <param name="y1">The far y-coordinate   in meters. </param>     
        public void GetBoundaryLineSegment(int index, out float x0, out float y0, out float x1, out float y1)
        {
            if (_disposed) throw new ObjectDisposedException("BVTColorImage");
            int error_code = NativeMethods.BVTColorImage_GetBoundaryLineSegment(_handle, index, out x0, out y0, out x1, out y1);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Get the approximate bearing angle for the boundary at the specified index. A boundary may not necessarily start at the origin, so this
        /// approximation may be too imprecise for some applications.
        /// </summary>
        /// <param name="index">the zero-based index of the boundary </param>
        /// <returns>the approximate bearing in radians of this boundary </returns>     
        public float GetBoundaryRadiansApproximate(int index)
        {
            if (_disposed) throw new ObjectDisposedException("BVTColorImage");
            float radians;
            int error_code = NativeMethods.BVTColorImage_GetBoundaryRadiansApproximate(_handle, index, out radians);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            return radians;
        }

        /// <summary>
        /// Save the image in PPM (PortablePixMap) format. http://en.wikipedia.org/wiki/Netpbm_format
        /// </summary>
        /// <param name="file_name">File name to save to </param>       
        public void SavePPM(string file_name)
        {
            if (_disposed) throw new ObjectDisposedException("BVTColorImage");
            int error_code = NativeMethods.BVTColorImage_SavePPM(_handle, BVTSDK.InteropHelpers.StringToUtf8Ptr(file_name));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the height (in pixels) of this image
        /// </summary>
        /// <returns>image height</returns>     
        public int Height
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTColorImage");
                int height;
                int error_code = NativeMethods.BVTColorImage_GetHeight(_handle, out height);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return height;
            }
        }

        /// <summary>
        /// Return the width (in pixels) of this image
        /// </summary>
        /// <returns>image width</returns>      
        public int Width
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTColorImage");
                int width;
                int error_code = NativeMethods.BVTColorImage_GetWidth(_handle, out width);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return width;
            }
        }

        /// <summary>
        /// Return the max range (in meters) to a non-blank pixel in the image
        /// </summary>
        /// <returns>max range to a non-blank pixel in the image</returns>      
        public float MaxRangeOfPixel
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTColorImage");
                float maxRange;
                int error_code = NativeMethods.BVTColorImage_GetMaxRangeOfPixel(_handle, out maxRange);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return maxRange;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Image type constant (IMAGETYPE_*) </returns>       
        public ImageType ImageType
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTColorImage");
                int type;
                int error_code = NativeMethods.BVTColorImage_GetImageType(_handle, out type);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return (ImageType) type;
            }
        }

        /// <summary>
        /// Return the range resolution of this image.
        /// The resolution is returned in meters per pixel row.
        /// </summary>
        /// <returns>image range resolution</returns>       
        public double RangeResolution
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTColorImage");
                double resolution;
                int error_code = NativeMethods.BVTColorImage_GetRangeResolution(_handle, out resolution);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return resolution;
            }
        }

        /// <summary>
        /// Only valid for R-Theta images.
        /// Returns the bearing resolution, in degrees per pixel column.
        /// </summary>
        /// <returns>image bearing resolution</returns>     
        public double BearingResolution
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTColorImage");
                double resolution;
                int error_code = NativeMethods.BVTColorImage_GetBearingResolution(_handle, out resolution);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return resolution;
            }
        }

        /// <summary>
        /// Retrieve the image row of the origin.
        /// In most cases the origin row will be outside of the image boundaries (i.e., negative). The origin is the 'location' (in pixels) of the sonar head in image plane.
        /// </summary>
        /// <returns>pixel row</returns>        
        public int OriginRow
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTColorImage");
                int row;
                int error_code = NativeMethods.BVTColorImage_GetOriginRow(_handle, out row);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return row;
            }
        }

        /// <summary>
        /// Retrieve the image column of the origin.
        /// The origin is the 'location' (in pixels) of the
        /// sonar head in image plane.
        /// </summary>
        /// <returns>pixel column</returns>     
        public int OriginCol
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTColorImage");
                int column;
                int error_code = NativeMethods.BVTColorImage_GetOriginCol(_handle, out column);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return column;
            }
        }

        /// <summary>
        /// Retrieve the range (from the sonar head) of the specified pixel (in meters)
        /// </summary>
        /// <param name="row">pixel row </param>
        /// <param name="col">pixel col </param>
        /// <returns>range to given pixel </returns>        
        public double GetPixelRange(int row, int col)
        {
            if (_disposed) throw new ObjectDisposedException("BVTColorImage");
            double range;
            int error_code = NativeMethods.BVTColorImage_GetPixelRange(_handle, row, col, out range);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            return range;
        }

        /// <summary>
        /// Retrieve the bearing relative to the sonar head of the specified pixel
        /// </summary>
        /// <param name="row">pixel row </param>
        /// <param name="col">pixel col </param>
        /// <returns>bearing to given pixel </returns>      
        public double GetPixelRelativeBearing(int row, int col)
        {
            if (_disposed) throw new ObjectDisposedException("BVTColorImage");
            double bearing;
            int error_code = NativeMethods.BVTColorImage_GetPixelRelativeBearing(_handle, row, col, out bearing);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            return bearing;
        }

        /// <summary>
        /// Return the pixel coordinate at the specified physical location.
        /// The returned coordinate may be outside this image's bounds.
        /// </summary>
        /// <param name="range">range in meters </param>
        /// <param name="bearing">bearing in radians </param>
        /// <param name="x">pixel index in the X-axis </param>
        /// <param name="y">pixel index in the Y-axis </param>      
        public void GetPixelCoordinateAtRangeBearing(float range, float bearing, out int x, out int y)
        {
            if (_disposed) throw new ObjectDisposedException("BVTColorImage");
            int error_code = NativeMethods.BVTColorImage_GetPixelCoordinateAtRangeBearing(_handle, range, bearing, out x, out y);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the pixel coordinate at the specified physical location in the sonar's frame.
        /// The returned coordinate may be outside this image's bounds.
        /// </summary>
        /// <param name="x_meters">X distance in meters </param>
        /// <param name="y_meters">Y distance in meters </param>
        /// <param name="x">pixel index in the X-axis </param>
        /// <param name="y">pixel index in the Y-axis </param>      
        public void GetPixelCoordinateAtXY(float x_meters, float y_meters, out int x, out int y)
        {
            if (_disposed) throw new ObjectDisposedException("BVTColorImage");
            int error_code = NativeMethods.BVTColorImage_GetPixelCoordinateAtXY(_handle, x_meters, y_meters, out x, out y);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the minimum angle for the sonar's imaging field of view. 
        /// The angle is returned in degrees and referenced with respect to sonar head boresight (clockwise-positive).
        /// </summary>
        /// <returns>min. angle</returns>       
        public float FOVMinAngle
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTColorImage");
                float angle;
                int error_code = NativeMethods.BVTColorImage_GetFOVMinAngle(_handle, out angle);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return angle;
            }
        }

        /// <summary>
        /// Return the maximum angle for the sonar's imaging field of view. 
        /// The angle is returned in degrees and referenced with respect to sonar head boresight (clockwise-positive).
        /// </summary>
        /// <returns>max. angle</returns>       
        public float FOVMaxAngle
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTColorImage");
                float angle;
                int error_code = NativeMethods.BVTColorImage_GetFOVMaxAngle(_handle, out angle);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return angle;
            }
        }


        /// SDK object pointer
        internal HandleRef Handle
        {
            get { return _handle; }
        }
        private readonly HandleRef _handle;

        private bool _disposed;

        /// P/Invoke 'wrapper' class
        private static class NativeMethods
        {
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern IntPtr BVTColorImage_Create();
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern IntPtr BVTColorImage_Destroy(HandleRef obj);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetPixel(HandleRef obj, int row, int col, out UInt32 pixel);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_SetPixel(HandleRef obj, int row, int col, UInt32 pixel);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetRow(HandleRef obj, int row, out UInt32 rowPointer);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetBits(HandleRef obj, out UInt32 bitsPointer);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_CopyBits(HandleRef obj, UInt32[] data, UInt32 len);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetBoundaryCount(HandleRef obj, out int count);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetBoundaryLineSegment(HandleRef obj, int index, out float x0, out float y0, out float x1, out float y1);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetBoundaryRadiansApproximate(HandleRef obj, int index, out float radians);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_SavePPM(HandleRef obj, byte[] file_name);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetHeight(HandleRef obj, out int height);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetWidth(HandleRef obj, out int width);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetMaxRangeOfPixel(HandleRef obj, out float maxRange);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetImageType(HandleRef obj, out int type);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetRangeResolution(HandleRef obj, out double resolution);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetBearingResolution(HandleRef obj, out double resolution);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetOriginRow(HandleRef obj, out int row);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetOriginCol(HandleRef obj, out int column);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetPixelRange(HandleRef obj, int row, int col, out double range);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetPixelRelativeBearing(HandleRef obj, int row, int col, out double bearing);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetPixelCoordinateAtRangeBearing(HandleRef obj, float range, float bearing, out int x, out int y);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetPixelCoordinateAtXY(HandleRef obj, float x_meters, float y_meters, out int x, out int y);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetFOVMinAngle(HandleRef obj, out float angle);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTColorImage_GetFOVMaxAngle(HandleRef obj, out float angle);

        }
    }

}
