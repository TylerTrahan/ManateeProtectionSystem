///
/// This file has been generated by bvtidl.pl. DO NOT MODIFY!
///

using System;
using System.Runtime.InteropServices;


namespace BVTSDK
{
/// <summary>
/// NavData contains various types of user-accessible navigation parameter, which
/// can be saved to and retrieved from a sonar file on a per ping basis.
/// The NavData objects can be created and destroyed as needed. When the
/// ping functions are called to get or put the data, the data is copied.
/// This allows NavData objects to be pre-allocated and filled from various
/// instrument sources. It also allows the data to be copied from one
/// NavData object to the other.
/// NOTE: NavData changes will only be saved to a sonar of type FILE. 
/// </summary>
    public class NavData : IDisposable
    {
        public NavData()
        {
            IntPtr p = NativeMethods.BVTNavData_Create();
            _handle = new HandleRef(this, p);
        }

        internal NavData(IntPtr p)
        {
            _handle = new HandleRef(this, p);
        }

        /// Non-deterministic destruction of this object on the Finalizer thread
        ~NavData()
        {
            Dispose(false);
        }

        /// Dispose deterministically
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;
            _disposed = true;
            NativeMethods.BVTNavData_Destroy(_handle);
        }

        /// <summary>
        /// Clones the data from the passed NavData object to this object. Both objects
        /// must have already been created.
        /// </summary>
        /// <param name="navdata_to_clone">existing NavData object to copy from </param>        
        [ObsoleteAttribute("This method is obsolete.", false)]
        public void Clone(NavData navdata_to_clone)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_Clone(_handle, navdata_to_clone.Handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Clones the data from the passed NavData object to this object. Both objects
        /// must have already been created.
        /// </summary>
        /// <param name="navdata_to_clone">existing NavData object to copy from </param>        
        public void CloneFrom(NavData navdata_to_clone)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_CloneFrom(_handle, navdata_to_clone.Handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Clears all fields in the NavData object so that the object may
        /// be reused. Following a call to this method, IsEmpty() returns
        /// true.
        /// </summary>      
        public void Clear()
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_Clear(_handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns true(1) if the NavData object contains no valid data.
        /// </summary>
        /// <returns>true if this NavData object is empty</returns>     
        public bool IsEmpty
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                int empty;
                int error_code = NativeMethods.BVTNavData_IsEmpty(_handle, out empty);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return empty > 0;
            }
        }

        /// <summary>
        /// Combines the fields of two NavData objects according to the following rules:
        /// 1) If a field is populated in one object and empty in the other, the value from the populated object is kept
        /// 2) If a field is full in both objects, the value with the more
        /// recent timestamp is kept
        /// 3) If a field is empty in both objects, it remains empty
        /// </summary>
        /// <param name="other">The source NavData to merge into this NavData </param>      
        public void Merge(NavData other)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_Merge(_handle, other.Handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Clears all fields whose time of receipt is older than the value specified by timestamp (as provided by the system clock). Returns the number of valid fields left.
        /// </summary>
        /// <param name="timestamp">The absolute timestamp, in seconds, for data to be considered stale</param>
        /// <returns>the number of remaining valid fields after pruning stale fields</returns>      
        public int ClearStaleFields(double timestamp)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int remainingFieldCount;
            int error_code = NativeMethods.BVTNavData_ClearStaleFields(_handle, timestamp, out remainingFieldCount);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            return remainingFieldCount;
        }

        /// <summary>
        /// A single NavData object may contain data that was acquired over some length of time. This
        /// function allows the user to determine what that length is.
        /// </summary>
        /// <param name="start">The Unix timestamp representing the earliest data contained in the object </param>
        /// <param name="stop">The Unix timestamp representing the latest data contained in the object </param>     
        public void GetTimespan(out double start, out double stop)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetTimespan(_handle, out start, out stop);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the latitude. If no latitude was stored, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>latitude in degrees </returns>     
        public double Latitude
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double degrees;
                int error_code = NativeMethods.BVTNavData_GetLatitude(_handle, out degrees);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return degrees;
            }
        }

        /// <summary>
        /// Returns the latitude. If no latitude was stored, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>latitude in degrees </returns>     
        public bool TryGetLatitude(out double degrees)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetLatitude(_handle, out degrees);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                degrees = 0.0;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds </returns>        
        public double LatitudeTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetLatitudeTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Stores the latitude, as a signed floating point number of degrees.
        /// Latitudes in the Southern hemisphere are expressed as negative numbers.
        /// </summary>
        /// <param name="degrees">latitude in degrees </param>      
        public void SetLatitude(double degrees)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetLatitude(_handle, degrees);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the longitude. If no longitude was stored, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>longitude in degrees </returns>        
        public double Longitude
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double degrees;
                int error_code = NativeMethods.BVTNavData_GetLongitude(_handle, out degrees);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return degrees;
            }
        }

        /// <summary>
        /// Returns the longitude. If no longitude was stored, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>longitude in degrees </returns>        
        public bool TryGetLongitude(out double degrees)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetLongitude(_handle, out degrees);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                degrees = 0.0;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp</returns>        
        public double LongitudeTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetLongitudeTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Stores the longitude, as a signed floating point number of degrees.
        /// Longitudes in the Western hemisphere are expressed as negative numbers.
        /// </summary>
        /// <param name="degrees">longitude in degrees </param>     
        public void SetLongitude(double degrees)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetLongitude(_handle, degrees);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the estimated horizontal error (see next function for details). 
        /// If none was stored, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>potential error distance, in meters </returns>     
        public float HorizontalPrecisionError
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float error_meters;
                int error_code = NativeMethods.BVTNavData_GetHorizontalPrecisionError(_handle, out error_meters);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return error_meters;
            }
        }

        /// <summary>
        /// Returns the estimated horizontal error (see next function for details). 
        /// If none was stored, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>potential error distance, in meters </returns>     
        public bool TryGetHorizontalPrecisionError(out float error_meters)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetHorizontalPrecisionError(_handle, out error_meters);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                error_meters = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// )
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp</returns>        
        public double HorizontalPrecisionErrorTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetHorizontalPrecisionErrorTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Stores the estimated possible horizontal error. This is primarily (but not exclusively)
        /// intended for GPS systems, where there may be some doubt as to the
        /// quality of the position fix. HDOP is common, but not used here, as
        /// that is a unitless measure and varies between different manufacturers and models. <br>
        /// The idea is to use whatever calculations are appropriate for the 
        /// local navigation system, and store a possible error value in meters.
        /// Some GPS units will attempt to give this directly. (for example,
        /// the HPE field in the PGRME sentence, supplied by some Garmin units.)
        /// In the case of large errors, or old data, it may be best to either
        /// not store a position, or not store new data. (also consider using
        /// the NavData time parameter to store the time of last fix, which
        /// can then be compared to the ping time when the data is read back to
        /// determine the age of the GPS reading.)
        /// </summary>
        /// <param name="error_meters">potential error distance, in meters </param>     
        public void SetHorizontalPrecisionError(float error_meters)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetHorizontalPrecisionError(_handle, error_meters);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the height above Mean Sea Level. If no value was stored for
        /// this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>height in meters </returns>        
        public float Height
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float meters_above_geoid;
                int error_code = NativeMethods.BVTNavData_GetHeight(_handle, out meters_above_geoid);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return meters_above_geoid;
            }
        }

        /// <summary>
        /// Returns the height above Mean Sea Level. If no value was stored for
        /// this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>height in meters </returns>        
        public bool TryGetHeight(out float meters_above_geoid)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetHeight(_handle, out meters_above_geoid);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                meters_above_geoid = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp</returns>        
        public double HeightTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetHeightTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the height above Mean Sea Level (usually the EGM96 geoid)
        /// </summary>
        /// <param name="meters_above_geoid">height in meters </param>      
        public void SetHeight(float meters_above_geoid)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetHeight(_handle, meters_above_geoid);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the estimated vertical error (see next function for details). 
        /// If none was stored, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>potential error distance, in meters </returns>     
        public float VerticalPrecisionError
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float error_meters;
                int error_code = NativeMethods.BVTNavData_GetVerticalPrecisionError(_handle, out error_meters);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return error_meters;
            }
        }

        /// <summary>
        /// Returns the estimated vertical error (see next function for details). 
        /// If none was stored, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>potential error distance, in meters </returns>     
        public bool TryGetVerticalPrecisionError(out float error_meters)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetVerticalPrecisionError(_handle, out error_meters);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                error_meters = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp</returns>        
        public double VerticalPrecisionErrorTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetVerticalPrecisionErrorTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Stores the estimated possible vertical error (height) above 
        /// Mean Sea Level (EGM96 geoid).  For other notes, see the functions
        /// or Horizontal Precision Error, above.
        /// </summary>
        /// <param name="error_meters">potential error distance, in meters </param>     
        public void SetVerticalPrecisionError(float error_meters)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetVerticalPrecisionError(_handle, error_meters);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the depth. If no value was stored for this ping, returns
        /// BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>depth in floating point meters </returns>      
        public float Depth
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float meters_below_surface;
                int error_code = NativeMethods.BVTNavData_GetDepth(_handle, out meters_below_surface);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return meters_below_surface;
            }
        }

        /// <summary>
        /// Returns the depth. If no value was stored for this ping, returns
        /// BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>depth in floating point meters </returns>      
        public bool TryGetDepth(out float meters_below_surface)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetDepth(_handle, out meters_below_surface);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                meters_below_surface = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds </returns>        
        public double DepthTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetDepthTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the depth.
        /// </summary>
        /// <param name="meters_below_surface">depth in floating point meters </param>      
        public void SetDepth(float meters_below_surface)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetDepth(_handle, meters_below_surface);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the altitude. If no value was stored for this ping, returns
        /// BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>altitude in floating point meters </returns>       
        public float Altitude
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float meters_above_bottom;
                int error_code = NativeMethods.BVTNavData_GetAltitude(_handle, out meters_above_bottom);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return meters_above_bottom;
            }
        }

        /// <summary>
        /// Returns the altitude. If no value was stored for this ping, returns
        /// BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>altitude in floating point meters </returns>       
        public bool TryGetAltitude(out float meters_above_bottom)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetAltitude(_handle, out meters_above_bottom);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                meters_above_bottom = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double AltitudeTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetAltitudeTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the altitude.
        /// </summary>
        /// <param name="meters_above_bottom">altitude in floating point meters </param>        
        public void SetAltitude(float meters_above_bottom)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetAltitude(_handle, meters_above_bottom);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the heading relative to True North. If no value was stored
        /// for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>True heading, in degrees </returns>        
        public float Heading
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float degrees_true;
                int error_code = NativeMethods.BVTNavData_GetHeading(_handle, out degrees_true);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return degrees_true;
            }
        }

        /// <summary>
        /// Returns the heading relative to True North. If no value was stored
        /// for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>True heading, in degrees </returns>        
        public bool TryGetHeading(out float degrees_true)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetHeading(_handle, out degrees_true);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                degrees_true = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double HeadingTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetHeadingTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the heading relative to True North.
        /// </summary>
        /// <param name="degrees_true">True heading, in degrees </param>        
        public void SetHeading(float degrees_true)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetHeading(_handle, degrees_true);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the velocity along the heading. If no value was stored
        /// for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>velocity, in meters per second </returns>      
        public float HeadingVelocity
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float meters_per_second;
                int error_code = NativeMethods.BVTNavData_GetHeadingVelocity(_handle, out meters_per_second);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return meters_per_second;
            }
        }

        /// <summary>
        /// Returns the velocity along the heading. If no value was stored
        /// for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>velocity, in meters per second </returns>      
        public bool TryGetHeadingVelocity(out float meters_per_second)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetHeadingVelocity(_handle, out meters_per_second);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                meters_per_second = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double HeadingVelocityTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetHeadingVelocityTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the velocity along the heading.
        /// </summary>
        /// <param name="meters_per_second">velocity, in meters per second </param>     
        public void SetHeadingVelocity(float meters_per_second)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetHeadingVelocity(_handle, meters_per_second);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the course over ground (true). If no value was stored for
        /// this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>course over ground, true, in degrees </returns>        
        public float CourseOverGround
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float degrees_true;
                int error_code = NativeMethods.BVTNavData_GetCourseOverGround(_handle, out degrees_true);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return degrees_true;
            }
        }

        /// <summary>
        /// Returns the course over ground (true). If no value was stored for
        /// this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>course over ground, true, in degrees </returns>        
        public bool TryGetCourseOverGround(out float degrees_true)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetCourseOverGround(_handle, out degrees_true);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                degrees_true = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double CourseOverGroundTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetCourseOverGroundTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the course over ground, true.
        /// </summary>
        /// <param name="degrees_true">course over ground, true, in degrees </param>        
        public void SetCourseOverGround(float degrees_true)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetCourseOverGround(_handle, degrees_true);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the speed over ground. If no value was stored for this ping,
        /// returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>speed over ground, in meters per second </returns>     
        public float SpeedOverGround
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float meters_per_second;
                int error_code = NativeMethods.BVTNavData_GetSpeedOverGround(_handle, out meters_per_second);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return meters_per_second;
            }
        }

        /// <summary>
        /// Returns the speed over ground. If no value was stored for this ping,
        /// returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>speed over ground, in meters per second </returns>     
        public bool TryGetSpeedOverGround(out float meters_per_second)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetSpeedOverGround(_handle, out meters_per_second);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                meters_per_second = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double SpeedOverGroundTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetSpeedOverGroundTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the speed over ground.
        /// </summary>
        /// <param name="meters_per_second">speed over ground, in meters per second </param>        
        public void SetSpeedOverGround(float meters_per_second)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetSpeedOverGround(_handle, meters_per_second);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Get the pitch angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>pitch angle, in floating point degrees, bow up is positive  </returns>     
        public float PitchAngle
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float degrees_bow_up;
                int error_code = NativeMethods.BVTNavData_GetPitchAngle(_handle, out degrees_bow_up);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return degrees_bow_up;
            }
        }

        /// <summary>
        /// Get the pitch angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>pitch angle, in floating point degrees, bow up is positive  </returns>     
        public bool TryGetPitchAngle(out float degrees_bow_up)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetPitchAngle(_handle, out degrees_bow_up);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                degrees_bow_up = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double PitchAngleTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetPitchAngleTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the pitch angle.
        /// </summary>
        /// <param name="degrees_bow_up">pitch angle, in floating point degrees, bow up is positive  </param>       
        public void SetPitchAngle(float degrees_bow_up)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetPitchAngle(_handle, degrees_bow_up);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Get the roll angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>roll angle, in floating point degrees, port side up is positive  </returns>        
        public float RollAngle
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float degrees_port_up;
                int error_code = NativeMethods.BVTNavData_GetRollAngle(_handle, out degrees_port_up);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return degrees_port_up;
            }
        }

        /// <summary>
        /// Get the roll angle. If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>roll angle, in floating point degrees, port side up is positive  </returns>        
        public bool TryGetRollAngle(out float degrees_port_up)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetRollAngle(_handle, out degrees_port_up);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                degrees_port_up = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double RollAngleTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetRollAngleTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the roll angle.
        /// </summary>
        /// <param name="degrees_port_up">roll angle, in floating point degrees, port side up is positive  </param>     
        public void SetRollAngle(float degrees_port_up)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetRollAngle(_handle, degrees_port_up);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Get the roll angle (but see notes with SetYawAngle() ). If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>yaw angle, in floating point degrees </returns>        
        public float YawAngle
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float degrees_bow_to_starboard;
                int error_code = NativeMethods.BVTNavData_GetYawAngle(_handle, out degrees_bow_to_starboard);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return degrees_bow_to_starboard;
            }
        }

        /// <summary>
        /// Get the roll angle (but see notes with SetYawAngle() ). If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>yaw angle, in floating point degrees </returns>        
        public bool TryGetYawAngle(out float degrees_bow_to_starboard)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetYawAngle(_handle, out degrees_bow_to_starboard);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                degrees_bow_to_starboard = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double YawAngleTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetYawAngleTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the yaw angle. <br>
        /// NOTE: This is NOT the same as the Heading field. Heading is for the
        /// normal navigation use of Heading, often from a compass. This field is
        /// intended to store raw data from other research instruments, in case
        /// you need another storage spot. To keep everyone using the fields the
        /// same way so that files can be interchanged, please use SetHeading
        /// for the normal heading, and SetYawAngle() only for special uses.
        /// </summary>
        /// <param name="degrees_bow_to_starboard">yaw angle, in floating point degrees, to starboard is positive  </param>     
        public void SetYawAngle(float degrees_bow_to_starboard)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetYawAngle(_handle, degrees_bow_to_starboard);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the rate of pitch change.
        /// If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>rate of pitch change in degrees per second </returns>      
        public float PitchRate
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float degrees_per_second;
                int error_code = NativeMethods.BVTNavData_GetPitchRate(_handle, out degrees_per_second);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return degrees_per_second;
            }
        }

        /// <summary>
        /// Returns the rate of pitch change.
        /// If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>rate of pitch change in degrees per second </returns>      
        public bool TryGetPitchRate(out float degrees_per_second)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetPitchRate(_handle, out degrees_per_second);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                degrees_per_second = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double PitchRateTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetPitchRateTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the the rate of pitch change.
        /// </summary>
        /// <param name="degrees_per_second">rate of pitch change in degrees per second </param>        
        public void SetPitchRate(float degrees_per_second)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetPitchRate(_handle, degrees_per_second);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the rate of roll change.
        /// If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>rate of roll change in degrees per second </returns>       
        public float RollRate
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float degrees_per_second;
                int error_code = NativeMethods.BVTNavData_GetRollRate(_handle, out degrees_per_second);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return degrees_per_second;
            }
        }

        /// <summary>
        /// Returns the rate of roll change.
        /// If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>rate of roll change in degrees per second </returns>       
        public bool TryGetRollRate(out float degrees_per_second)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetRollRate(_handle, out degrees_per_second);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                degrees_per_second = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double RollRateTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetRollRateTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the the rate of change in roll.
        /// </summary>
        /// <param name="degrees_per_second">rate of roll change in floating point degrees per second </param>      
        public void SetRollRate(float degrees_per_second)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetRollRate(_handle, degrees_per_second);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the rate of change in yaw (heading).  If no value was stored for this ping,
        /// returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>rate of yaw change in floating point degrees per second </returns>     
        public float YawRate
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float degrees_per_second;
                int error_code = NativeMethods.BVTNavData_GetYawRate(_handle, out degrees_per_second);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return degrees_per_second;
            }
        }

        /// <summary>
        /// Returns the rate of change in yaw (heading).  If no value was stored for this ping,
        /// returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>rate of yaw change in floating point degrees per second </returns>     
        public bool TryGetYawRate(out float degrees_per_second)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetYawRate(_handle, out degrees_per_second);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                degrees_per_second = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double YawRateTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetYawRateTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the rate of change in yaw (heading).
        /// </summary>
        /// <param name="degrees_per_second">rate of yaw change in floating point degrees per second </param>       
        public void SetYawRate(float degrees_per_second)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetYawRate(_handle, degrees_per_second);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Gets the stored acceleration along the X axis. If no value was stored for this ping,
        /// returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>acceleration along X axis, in milli-g </returns>       
        public float AccelerationX
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float accel_mg;
                int error_code = NativeMethods.BVTNavData_GetAccelerationX(_handle, out accel_mg);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return accel_mg;
            }
        }

        /// <summary>
        /// Gets the stored acceleration along the X axis. If no value was stored for this ping,
        /// returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>acceleration along X axis, in milli-g </returns>       
        public bool TryGetAccelerationX(out float accel_mg)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetAccelerationX(_handle, out accel_mg);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                accel_mg = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double AccelerationXTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetAccelerationXTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Sets the stored acceleration along the X axis. Intended to store
        /// raw values of accelerometers.
        /// </summary>
        /// <param name="accel_mg">acceleration along X axis, in milli-g </param>       
        public void SetAccelerationX(float accel_mg)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetAccelerationX(_handle, accel_mg);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Gets the stored acceleration along the Y axis. If no value was stored for this ping,
        /// returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>acceleration along Y axis, in milli-g </returns>       
        public float AccelerationY
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float accel_mg;
                int error_code = NativeMethods.BVTNavData_GetAccelerationY(_handle, out accel_mg);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return accel_mg;
            }
        }

        /// <summary>
        /// Gets the stored acceleration along the Y axis. If no value was stored for this ping,
        /// returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>acceleration along Y axis, in milli-g </returns>       
        public bool TryGetAccelerationY(out float accel_mg)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetAccelerationY(_handle, out accel_mg);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                accel_mg = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double AccelerationYTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetAccelerationYTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Sets the stored acceleration along the Y axis. Intended to store
        /// raw values of accelerometers.
        /// </summary>
        /// <param name="accel_mg">acceleration along Y axis, in milli-g </param>       
        public void SetAccelerationY(float accel_mg)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetAccelerationY(_handle, accel_mg);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Gets the stored acceleration along the Z axis. If no value was stored for this ping,
        /// returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>acceleration along Z axis, in milli-g </returns>       
        public float AccelerationZ
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float accel_mg;
                int error_code = NativeMethods.BVTNavData_GetAccelerationZ(_handle, out accel_mg);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return accel_mg;
            }
        }

        /// <summary>
        /// Gets the stored acceleration along the Z axis. If no value was stored for this ping,
        /// returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>acceleration along Z axis, in milli-g </returns>       
        public bool TryGetAccelerationZ(out float accel_mg)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetAccelerationZ(_handle, out accel_mg);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                accel_mg = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double AccelerationZTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetAccelerationZTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Sets the stored acceleration along the Z axis. Intended to store
        /// raw values of accelerometers.
        /// </summary>
        /// <param name="accel_mg">acceleration along Z axis, in milli-g </param>       
        public void SetAccelerationZ(float accel_mg)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetAccelerationZ(_handle, accel_mg);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the offset, to the north, from a user-defined fixed point.
        /// If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>offset to the north, in floating point meters </returns>       
        public double OffsetNorth
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double meters;
                int error_code = NativeMethods.BVTNavData_GetOffsetNorth(_handle, out meters);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return meters;
            }
        }

        /// <summary>
        /// Returns the offset, to the north, from a user-defined fixed point.
        /// If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>offset to the north, in floating point meters </returns>       
        public bool TryGetOffsetNorth(out double meters)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetOffsetNorth(_handle, out meters);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                meters = 0.0;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double OffsetNorthTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetOffsetNorthTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the offset from a user-defined fixed point.
        /// </summary>
        /// <param name="meters">offset to the north, in floating point meters </param>     
        public void SetOffsetNorth(double meters)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetOffsetNorth(_handle, meters);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the offset, to the east, from a user-defined fixed point.
        /// If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>offset to the east, in floating point meters </returns>        
        public double OffsetEast
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double meters;
                int error_code = NativeMethods.BVTNavData_GetOffsetEast(_handle, out meters);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return meters;
            }
        }

        /// <summary>
        /// Returns the offset, to the east, from a user-defined fixed point.
        /// If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>offset to the east, in floating point meters </returns>        
        public bool TryGetOffsetEast(out double meters)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetOffsetEast(_handle, out meters);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                meters = 0.0;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double OffsetEastTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetOffsetEastTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Store the offset from a user-defined fixed point.
        /// </summary>
        /// <param name="meters">offset to the east, in floating point meters </param>      
        public void SetOffsetEast(double meters)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetOffsetEast(_handle, meters);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Gets a flag value which indicates if the East and North offset values
        /// are from the stored Latitude and Longitude. (see more below...)
        /// If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>either 1 or 0, to indicate true or false, respectively </returns>      
        public int OffsetIsFromLatLongFlag
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                int is_true;
                int error_code = NativeMethods.BVTNavData_GetOffsetIsFromLatLongFlag(_handle, out is_true);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return is_true;
            }
        }

        /// <summary>
        /// Gets a flag value which indicates if the East and North offset values
        /// are from the stored Latitude and Longitude. (see more below...)
        /// If no value was stored for this ping, returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>either 1 or 0, to indicate true or false, respectively </returns>      
        public bool TryGetOffsetIsFromLatLongFlag(out int is_true)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetOffsetIsFromLatLongFlag(_handle, out is_true);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                is_true = 0;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double OffsetIsFromLatLongFlagTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetOffsetIsFromLatLongFlagTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Sets a flag to indicate if the East and North offset values are from
        /// the stored Latitude and Longitude. If so, then software reading the
        /// file will know to adjust appropriately. If from some special location,
        /// perhaps the UserNavString could be used to indicate the reference
        /// point? If nothing is stored, then the value is assumed to be false.
        /// </summary>
        /// <param name="is_true">either 1 or 0, to indicate true or false, respectively </param>       
        public void SetOffsetIsFromLatLongFlag(int is_true)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetOffsetIsFromLatLongFlag(_handle, is_true);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the stored user string, in null-terminated form. If no
        /// string was stored, returns a null string.
        /// </summary>
        /// <returns>user-defined description string </returns>     
        public string UserNavString
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                byte[] navString = new byte[256];
                int bufferLength = 255;
                int error_code = NativeMethods.BVTNavData_GetUserNavString(_handle, navString, bufferLength);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return BVTSDK.InteropHelpers.Utf8ToString(navString);
            }
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double UserNavStringTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetUserNavStringTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Stores a user-defined string related to navigation. It is highly
        /// recommended to store some identifier such that the data is
        /// recognizable as you own. <br>
        /// Examples of possible uses might be to store locations based on 
        /// coordinate systems other than GPS, indicating information about
        /// the use of the north and east offset parameters, additional fields
        /// from a GPS receiver, or any other information which might change
        /// dynamically.
        /// </summary>
        /// <param name="string_in">string to be stored, null terminated, max length 80 chars </param>      
        public void SetUserNavString(string string_in)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetUserNavString(_handle, BVTSDK.InteropHelpers.StringToUtf8Ptr(string_in));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the stored Source string, in null-terminated form. If no
        /// string was stored, returns a null string.
        /// </summary>
        /// <returns>The source string.  </returns>     
        public string Source
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                byte[] source_string = new byte[256];
                int source_string_length = 255;
                int error_code = NativeMethods.BVTNavData_GetSource(_handle, source_string, source_string_length);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return BVTSDK.InteropHelpers.Utf8ToString(source_string);
            }
        }

        /// <summary>
        /// Returns the length of the stored Source string.
        /// </summary>
        /// <returns>The length in characters of the stored Source string. </returns>       
        public int SourceLength
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                int source_string_length;
                int error_code = NativeMethods.BVTNavData_GetSourceLength(_handle, out source_string_length);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return source_string_length;
            }
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double SourceTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetSourceTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Stores a user-defined string which identifies the NavData source, 
        /// e.g. "MRU", "GPS", "Compass". <br>.
        /// </summary>
        /// <param name="source_string">string to be stored, null terminated, max length 80 chars </param>      
        public void SetSource(string source_string)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetSource(_handle, BVTSDK.InteropHelpers.StringToUtf8Ptr(source_string));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the stored UTM zone and grid number, in null-terminated form. If no
        /// string was stored, returns a null string.
        /// </summary>
        /// <returns>output char buffer to hold zone string</returns>       
        public string UTMLongitudeZone
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                byte[] zone = new byte[256];
                int bufLength = 255;
                int error_code = NativeMethods.BVTNavData_GetUTMLongitudeZone(_handle, zone, bufLength);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return BVTSDK.InteropHelpers.Utf8ToString(zone);
            }
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double UTMLongitudeZoneTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetUTMLongitudeZoneTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Stores a string which identifies the UTM Zone and grid used as the
        /// basis for Northing and Easting values. Zones range from [1,60], grids are lettered from
        /// C-X not including O or I. Acceptable strings are of the form "1G" or "03F" or "54T".
        /// </summary>
        /// <param name="zone_string">zone and grid to be stored, null terminated. Should be either 2 or 3 characters </param>      
        public void SetUTMLongitudeZone(string zone_string)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetUTMLongitudeZone(_handle, BVTSDK.InteropHelpers.StringToUtf8Ptr(zone_string));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Stores a heave value, which is expected to be supplied by an MRU.
        /// </summary>
        /// <param name="heave_in_meters"></param>      
        public void SetHeave(float heave_in_meters)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetHeave(_handle, heave_in_meters);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double HeaveTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetHeaveTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Gets the stored heave. If no value was stored for this ping,
        /// returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>Returns the heave in meters. </returns>        
        public float Heave
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                float heave_in_meters;
                int error_code = NativeMethods.BVTNavData_GetHeave(_handle, out heave_in_meters);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return heave_in_meters;
            }
        }

        /// <summary>
        /// Gets the stored heave. If no value was stored for this ping,
        /// returns BVT_NAV_NO_DATA.
        /// </summary>
        /// <returns>Returns the heave in meters. </returns>        
        public bool TryGetHeave(out float heave_in_meters)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetHeave(_handle, out heave_in_meters);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                heave_in_meters = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Return the data's timestamp in seconds since 00:00:00 UTC, January 1, 1970 
        /// NavData is timestamped using a standard UNIX time stamp. This is 
        /// a similar value to that returned by the time() C standard library 
        /// function. In fact, the only difference is the addition of fractional seconds.
        /// </summary>
        /// <returns>navigation timestamp in seconds </returns>     
        public double NavTime
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double seconds;
                int error_code = NativeMethods.BVTNavData_GetNavTime(_handle, out seconds);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return seconds;
            }
        }

        /// <summary>
        /// Return the data's timestamp in seconds since 00:00:00 UTC, January 1, 1970 
        /// NavData is timestamped using a standard UNIX time stamp. This is 
        /// a similar value to that returned by the time() C standard library 
        /// function. In fact, the only difference is the addition of fractional seconds.
        /// </summary>
        /// <returns>navigation timestamp in seconds </returns>     
        public bool TryGetNavTime(out double seconds)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_GetNavTime(_handle, out seconds);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                seconds = 0.0;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Returns the Unix epoch time at which the field was set, including fractional seconds. 
        /// If no data was stored, the returns zero.
        /// This field may be compared to the output of NavTime() to get a temporary estimate of the offset
        /// between the system clock and the device clock. Note that this estimate will be subeject to 
        /// drift.
        /// NOTE: Timestamps are generated based on the value of the system clock at the time the
        /// field was set. As such, they are subject to substantial error due to clock drift and
        /// system latency and are in no way synchronized to any global standard. If such synchronization
        /// is required, please use the NavTime field and consider using a PPS signal.
        /// </summary>
        /// <returns>timestamp in seconds</returns>     
        public double NavTimeTimestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTNavData");
                double timestamp;
                int error_code = NativeMethods.BVTNavData_GetNavTimeTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Set the NavData's internal time stamp.  See NavTime() for more information. 
        /// </summary>
        /// <param name="sec">Timestamp in seconds since 00:00:00 UTC, January 1, 1970 </param>     
        public void SetNavTime(double sec)
        {
            if (_disposed) throw new ObjectDisposedException("BVTNavData");
            int error_code = NativeMethods.BVTNavData_SetNavTime(_handle, sec);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }


        /// SDK object pointer
        internal HandleRef Handle
        {
            get { return _handle; }
        }
        private readonly HandleRef _handle;

        private bool _disposed;

        /// P/Invoke 'wrapper' class
        private static class NativeMethods
        {
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern IntPtr BVTNavData_Create();
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern IntPtr BVTNavData_Destroy(HandleRef obj);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_Clone(HandleRef obj, HandleRef navdata_to_clone);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_CloneFrom(HandleRef obj, HandleRef navdata_to_clone);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_Clear(HandleRef obj);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_IsEmpty(HandleRef obj, out int empty);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_Merge(HandleRef obj, HandleRef other);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_ClearStaleFields(HandleRef obj, double timestamp, out int remainingFieldCount);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetTimespan(HandleRef obj, out double start, out double stop);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetLatitude(HandleRef obj, out double degrees);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetLatitudeTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetLatitude(HandleRef obj, double degrees);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetLongitude(HandleRef obj, out double degrees);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetLongitudeTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetLongitude(HandleRef obj, double degrees);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetHorizontalPrecisionError(HandleRef obj, out float error_meters);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetHorizontalPrecisionErrorTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetHorizontalPrecisionError(HandleRef obj, float error_meters);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetHeight(HandleRef obj, out float meters_above_geoid);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetHeightTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetHeight(HandleRef obj, float meters_above_geoid);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetVerticalPrecisionError(HandleRef obj, out float error_meters);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetVerticalPrecisionErrorTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetVerticalPrecisionError(HandleRef obj, float error_meters);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetDepth(HandleRef obj, out float meters_below_surface);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetDepthTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetDepth(HandleRef obj, float meters_below_surface);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetAltitude(HandleRef obj, out float meters_above_bottom);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetAltitudeTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetAltitude(HandleRef obj, float meters_above_bottom);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetHeading(HandleRef obj, out float degrees_true);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetHeadingTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetHeading(HandleRef obj, float degrees_true);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetHeadingVelocity(HandleRef obj, out float meters_per_second);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetHeadingVelocityTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetHeadingVelocity(HandleRef obj, float meters_per_second);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetCourseOverGround(HandleRef obj, out float degrees_true);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetCourseOverGroundTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetCourseOverGround(HandleRef obj, float degrees_true);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetSpeedOverGround(HandleRef obj, out float meters_per_second);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetSpeedOverGroundTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetSpeedOverGround(HandleRef obj, float meters_per_second);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetPitchAngle(HandleRef obj, out float degrees_bow_up);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetPitchAngleTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetPitchAngle(HandleRef obj, float degrees_bow_up);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetRollAngle(HandleRef obj, out float degrees_port_up);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetRollAngleTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetRollAngle(HandleRef obj, float degrees_port_up);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetYawAngle(HandleRef obj, out float degrees_bow_to_starboard);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetYawAngleTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetYawAngle(HandleRef obj, float degrees_bow_to_starboard);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetPitchRate(HandleRef obj, out float degrees_per_second);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetPitchRateTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetPitchRate(HandleRef obj, float degrees_per_second);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetRollRate(HandleRef obj, out float degrees_per_second);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetRollRateTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetRollRate(HandleRef obj, float degrees_per_second);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetYawRate(HandleRef obj, out float degrees_per_second);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetYawRateTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetYawRate(HandleRef obj, float degrees_per_second);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetAccelerationX(HandleRef obj, out float accel_mg);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetAccelerationXTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetAccelerationX(HandleRef obj, float accel_mg);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetAccelerationY(HandleRef obj, out float accel_mg);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetAccelerationYTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetAccelerationY(HandleRef obj, float accel_mg);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetAccelerationZ(HandleRef obj, out float accel_mg);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetAccelerationZTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetAccelerationZ(HandleRef obj, float accel_mg);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetOffsetNorth(HandleRef obj, out double meters);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetOffsetNorthTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetOffsetNorth(HandleRef obj, double meters);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetOffsetEast(HandleRef obj, out double meters);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetOffsetEastTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetOffsetEast(HandleRef obj, double meters);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetOffsetIsFromLatLongFlag(HandleRef obj, out int is_true);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetOffsetIsFromLatLongFlagTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetOffsetIsFromLatLongFlag(HandleRef obj, int is_true);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetUserNavString(HandleRef obj, byte[] navString, int bufferLength);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetUserNavStringTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetUserNavString(HandleRef obj, byte[] string_in);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetSource(HandleRef obj, byte[] source_string, int source_string_length);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetSourceLength(HandleRef obj, out int source_string_length);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetSourceTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetSource(HandleRef obj, byte[] source_string);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetUTMLongitudeZone(HandleRef obj, byte[] zone, int bufLength);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetUTMLongitudeZoneTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetUTMLongitudeZone(HandleRef obj, byte[] zone_string);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetHeave(HandleRef obj, float heave_in_meters);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetHeaveTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetHeave(HandleRef obj, out float heave_in_meters);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetNavTime(HandleRef obj, out double seconds);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_GetNavTimeTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTNavData_SetNavTime(HandleRef obj, double sec);

        }
    }

}
