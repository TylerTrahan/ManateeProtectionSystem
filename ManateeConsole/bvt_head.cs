///
/// This file has been generated by bvtidl.pl. DO NOT MODIFY!
///

using System;
using System.Runtime.InteropServices;


namespace BVTSDK
{
/// <summary>
/// A head consists of a group of co-planar transducers which are
/// operated simultaneously to produce (ultimately) a single 2d
/// image.  The Head object provides functions to change the 
/// range window as well as produce pings.
/// </summary>
    public class Head : IDisposable
    {
        internal Head(Sonar parent, IntPtr p)
        {
            _handle = new HandleRef(this, p);
            _parent = parent;
        }

        internal Head(IntPtr p)
        {
            _handle = new HandleRef(this, p);
        }

        /// Non-deterministic destruction of this object on the Finalizer thread
        ~Head()
        {
            Dispose(false);
        }

        /// Dispose deterministically
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;
            _disposed = true;
            NativeMethods.BVTHead_Destroy(_handle);
        }

        /// <summary>
        /// Retrieve the Head's ID.
        /// </summary>
        /// <returns>ID for this head</returns>     
        public int HeadID
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int headId;
                int error_code = NativeMethods.BVTHead_GetHeadID(_handle, out headId);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return headId;
            }
        }

        /// <summary>
        /// Retrieves a copy of a the name of the head. The head name is currently
        /// set only at the factory, and is simply "Head" on many sonars. Only special
        /// order sonars with multiple heads are likely to have a different name.<br>
        /// The length of the name has no actual limit, though 80 characters
        /// would seem to be more than enough.
        /// </summary>
        /// <returns>buffer to hold the null-terminated string to be passed back </returns>     
        public string HeadName
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                byte[] buffer = new byte[256];
                int buffer_size = 255;
                int error_code = NativeMethods.BVTHead_GetHeadName(_handle, buffer, buffer_size);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return BVTSDK.InteropHelpers.Utf8ToString(buffer);
            }
        }

        /// <summary>
        /// Persistently sets the name of the head. This should not be done frequently due
        /// wear on the sonar's onboard storage (Flash memory). The head name is currently
        /// set at the factory, and is simply "Head" on many sonars. Only special
        /// order sonars with multiple heads are likely to have a different name.
        /// </summary>
        /// <param name="name">null-terminated name string. </param>        
        public void SetHeadName(string name)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetHeadName(_handle, BVTSDK.InteropHelpers.StringToUtf8Ptr(name));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Set the range to be acquired.
        /// @note The start range must be greater than or equal to @ref MinimumRange, and the stop range must be less than or equal to @ref MaximumRange
        /// \warning You may not call this during recording on either the source sonar or the destination file sonar.
        /// </summary>
        /// <param name="start">Start range in meters. </param>
        /// <param name="stop">Stop range in meters. </param>       
        public void SetRange(float start, float stop)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetRange(_handle, start, stop);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Retrieve the current starting range in meters
        /// </summary>
        /// <returns>start range in meters</returns>        
        public float StartRange
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                float start;
                int error_code = NativeMethods.BVTHead_GetStartRange(_handle, out start);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return start;
            }
        }

        /// <summary>
        /// Retrieve the current stopping range in meters.
        /// </summary>
        /// <returns>stop range in meters</returns>     
        public float StopRange
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                float stop;
                int error_code = NativeMethods.BVTHead_GetStopRange(_handle, out stop);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return stop;
            }
        }

        /// <summary>
        /// Return the minimum allowable range for this head.
        /// </summary>
        /// <returns>minimum range in meters</returns>      
        public float MinimumRange
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                float range;
                int error_code = NativeMethods.BVTHead_GetMinimumRange(_handle, out range);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return range;
            }
        }

        /// <summary>
        /// Return the maximum allowable range for this head.
        /// </summary>
        /// <returns>maximum range in meters</returns>      
        public float MaximumRange
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                float range;
                int error_code = NativeMethods.BVTHead_GetMaximumRange(_handle, out range);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return range;
            }
        }

        /// <summary>
        /// Set the start range of this head in meters.
        /// @note The start range must be greater than or equal to @ref MinimumRange.
        /// </summary>
        /// <param name="start">Start range in meters </param>      
        public void SetStartRange(float start)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetStartRange(_handle, start);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Set the stop range of this head in meters.
        /// @note The stop range must be less than or equal to @ref MaximumRange
        /// </summary>
        /// <param name="stop">Stop range in meters </param>        
        public void SetStopRange(float stop)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetStopRange(_handle, stop);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// SetClippingThreshold function will set the maximum (+-) raw data 
        /// value from the ADC.  If this threshold is reached the entire signal 
        /// is zeroed out so that clipping is not propagated through out the 
        /// image.  The threshold is an integer ranging from 1 to 4096 (2^12).
        /// </summary>
        /// <param name="threshold">The clipping threshold. Allowed values: 1 to 4096 (2^12) </param>       
        [ObsoleteAttribute("This method is obsolete.", false)]
        public void SetClippingThreshold(int threshold)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetClippingThreshold(_handle, threshold);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// [obsolete]
        /// ClippingThreshold returns the integer value of the clipping threshold 
        /// </summary>
        /// <returns>the clipping threshold </returns>      
        public int ClippingThreshold
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int threshold;
                int error_code = NativeMethods.BVTHead_GetClippingThreshold(_handle, out threshold);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return threshold;
            }
        }

        /// <summary>
        /// [obsolete]
        /// The EnableClippingThreshold needs to be called  first before setting the 
        /// clipping threshold.  A value of true  will enable the feature while a value
        /// of false will disable it.
        /// </summary>
        /// <param name="enable">True if the clipping threshold should be applied. </param>     
        public void EnableClippingThreshold(bool enable)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_EnableClippingThreshold(_handle, (enable ? 1 : 0));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the type of water the head is in.  The returned value will correspond to 
        /// one of the FLUIDTYPE_* constants.
        /// </summary>
        /// <returns>fluid type</returns>       
        public int FluidType
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int fluidType;
                int error_code = NativeMethods.BVTHead_GetFluidType(_handle, out fluidType);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return fluidType;
            }
        }

        /// <summary>
        /// Set the type of water the head is in
        /// </summary>
        /// <param name="fluid">The fluid type (one of the FLUIDTYPE_* constants) </param>      
        public void SetFluidType(FluidType fluid)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetFluidType(_handle, ((int) fluid));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the current speed of sound in water for this head in meters per second.
        /// Note that the returned sound speed is not measured by the sonar, but simply reflects the value currently set.
        /// </summary>
        /// <returns>speed of sound </returns>      
        public int SoundSpeed
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int speed;
                int error_code = NativeMethods.BVTHead_GetSoundSpeed(_handle, out speed);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return speed;
            }
        }

        /// <summary>
        /// Set the current speed of sound in water for this head in meters per second.
        /// </summary>
        /// <param name="speed">Sound speed in water, meters per second </param>        
        public void SetSoundSpeed(int speed)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetSoundSpeed(_handle, speed);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the additional analog gain in dB
        /// </summary>
        /// <returns>analog gain</returns>      
        public float GainAdjustment
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                float gain;
                int error_code = NativeMethods.BVTHead_GetGainAdjustment(_handle, out gain);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return gain;
            }
        }

        /// <summary>
        /// Set the additional analog gain. 
        /// </summary>
        /// <param name="gain">Additional analog gain in dB </param>        
        public void SetGainAdjustment(float gain)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetGainAdjustment(_handle, gain);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the time variable gain in dB/meter. Note that the parameter is per unit distance, not per unit time. This is a convenience to remove the dependence on the sound speed for clients.
        /// </summary>
        /// <returns>slope in dB/meter </returns>       
        public float TVGSlope
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                float slope;
                int error_code = NativeMethods.BVTHead_GetTVGSlope(_handle, out slope);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return slope;
            }
        }

        /// <summary>
        /// Set the  time variable analog gain. Note that the parameter is per unit distance, not per unit time. This is a convenience to remove the dependence on the sound speed for clients.
        /// </summary>
        /// <param name="tvg">Time variable gain in dB/meter </param>       
        public void SetTVGSlope(float tvg)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetTVGSlope(_handle, tvg);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return true if this Head has dynamic power management enabled.
        /// </summary>
        /// <returns>True if this Head has dynamic power management enabled. </returns>     
        public bool DynamicPowerManagement
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int is_enabled;
                int error_code = NativeMethods.BVTHead_GetDynamicPowerManagement(_handle, out is_enabled);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return is_enabled > 0;
            }
        }

        /// <summary>
        /// Note: Most BlueView sonars don't support dynamic power managment.
        /// </summary>
        /// <param name="enable">If true, enable dynamic power managment. </param>      
        public void SetDynamicPowerManagement(bool enable)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetDynamicPowerManagement(_handle, (enable ? 1 : 0));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Latest-generation BlueView sonar support two modes of operation,
        /// a standard and an alternate mode. The alternate mode provides improved imagery for
        /// wide field-of-view sonar (greater than 45 degrees) at the cost of a slower max
        /// ping rate, while dual mode maximizes ping rate but reduces image
        /// quality. This call provides the user details about whether the alternate
        /// ping mode is supported on the given sonar head.
        /// </summary>
        /// <returns>true (1) if supported, false (0) otherwise</returns>       
        public bool SupportsAlternatePingMode
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int is_supported;
                int error_code = NativeMethods.BVTHead_SupportsAlternatePingMode(_handle, out is_supported);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return is_supported > 0;
            }
        }

        /// <summary>
        /// Sets the ping mode on sonar head. It is only
        /// valid for sonar heads that support alternate ping mode.
        /// (see SupportsAlternatePingMode()).
        /// </summary>
        /// <param name="enabled">True or false. </param>       
        public void SetAlternatePingModeEnabled(bool enabled)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetAlternatePingModeEnabled(_handle, (enabled ? 1 : 0));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Obtains the ping mode for the given sonar head.
        /// It is only valid for sonar heads that support alternate ping mode
        /// selection (see SupportsAlternatePingModemd()).
        /// </summary>
        /// <returns>True or false. </returns>      
        public bool AlternatePingModeEnabled
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int enabled;
                int error_code = NativeMethods.BVTHead_GetAlternatePingModeEnabled(_handle, out enabled);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return enabled > 0;
            }
        }

        /// <summary>
        /// Return the center frequency(in Hz) of this head.
        /// </summary>
        /// <returns>center frequency </returns>        
        public int CenterFreq
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int frequency;
                int error_code = NativeMethods.BVTHead_GetCenterFreq(_handle, out frequency);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return frequency;
            }
        }

        /// <summary>
        /// Return the number of pings 'in' this head
        /// A head attached to a file might have more than one ping recorded.  However, a networked sonar will only have a single ping.
        /// </summary>
        /// <returns>ping count </returns>      
        public int PingCount
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int count;
                int error_code = NativeMethods.BVTHead_GetPingCount(_handle, out count);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return count;
            }
        }

        /// <summary>
        /// Retrieve a Ping from the Head
        /// If ping_num is less than 0, return the next ping in the file. Otherwise, load the specified ping.  
        /// If the Head is attached to a 'live' sonar (network), then GetPing always acquires a new ping.
        /// </summary>
        /// <param name="ping_num">The ping number to return </param>
        /// <returns>The returned Ping object</returns>     
        public Ping GetPing(int ping_num)
        {
            IntPtr ping_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_GetPing(_handle, ping_num, ref ping_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            Ping ping = new Ping(this, ping_ptr);
            return ping;
        }

        /// <summary>
        /// \note This Head must be attached to a 'file' sonar.
        /// Retrieve a Ping's metadata from the Head, skipping its signal data.
        /// \warning You cannot create imagery from the ping returned by this function.
        /// \warning Do not store the returned ping to another file unless you intend to never create imagery.
        /// If ping_num is less than 0, return the next ping in the file. Otherwise, load the specified ping.
        /// </summary>
        /// <param name="ping_num">The ping number to return </param>
        /// <returns>The returned Ping object</returns>     
        public Ping GetPingMetadataOnly(int ping_num)
        {
            IntPtr ping_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_GetPingMetadataOnly(_handle, ping_num, ref ping_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            Ping ping = new Ping(this, ping_ptr);
            return ping;
        }

        /// <summary>
        /// Retrieve a Ping from a networked Head.
        /// The Head must be attached to a 'live' sonar (network) which supports multicast pings.
        /// </summary>
        /// <param name="ping_num">The ping number to return, currently unused </param>
        /// <returns>The returned Ping object</returns>     
        public Ping GetPingMulticast(int ping_num)
        {
            IntPtr ping_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_GetPingMulticast(_handle, ping_num, ref ping_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            Ping ping = new Ping(this, ping_ptr);
            return ping;
        }

        /// <summary>
        /// Retrieve a multicast Ping from a networked Head, but do not ask the Head to emit a ping.
        /// The Head must be attached to a 'live' sonar (network) which supports multicast pings.
        /// See also: Sonar_SupportsMulticast
        /// </summary>
        /// <returns>The returned Ping object </returns>        
        public Ping ListenForPingMulticast()
        {
            IntPtr ping_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_ListenForPingMulticast(_handle, ref ping_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            Ping ping = new Ping(this, ping_ptr);
            return ping;
        }

        /// <summary>
        /// Write a ping to a file.
        /// \warning The source_ping's Head must match this Head.
        /// </summary>
        /// <param name="source_ping">The ping to write out </param>        
        public void PutPing(Ping source_ping)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_PutPing(_handle, source_ping.Handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Setting this to a non-zero number will cause a multicast ping to be emitted every N milliseconds.
        /// This is only supported on sonar with newer firmware, and support can be checked with @ref BVTSonar_SupportsMulticast.
        /// </summary>
        /// <param name="milliseconds">The number of milliseconds between each ping acquisition on the remote Head. </param>        
        public void SetPingInterval(int milliseconds)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetPingInterval(_handle, milliseconds);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>The number of milliseconds between each ping acquisition on the remote Head. </returns>        
        public int PingInterval
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int milliseconds;
                int error_code = NativeMethods.BVTHead_GetPingInterval(_handle, out milliseconds);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return milliseconds;
            }
        }

        /// <summary>
        /// Set the image processing resolution. The RES_AUTO setting is highly
        /// recommended, as it adapts via a formula according to the stop range,
        /// whereas the other ranges are fixed values, and should only be used
        /// in specialized cases, such as requesting high resolution for longer
        /// distances (which will increase the processing time required to 
        /// create the image). R-Theta images may use either this function or
        /// SetRangeResolution(), depending on the degree of control required.
        /// </summary>
        /// <param name="res">Resolution constant (IMAGERES_*)</param>      
        [ObsoleteAttribute("This method is obsolete.", false)]
        public void SetImageRes(ImageRes res)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetImageRes(_handle, ((int) res));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Requests a range resolution for R-Theta images. Also affects the
        /// range resolution for RangeProfile. Note that the exact range resolution
        /// may not be available, and the closest resolution will be set. The
        /// actual resolution can be obtained by querying the returned image
        /// or RangeProfile object.
        /// </summary>
        /// <param name="resolution_in_meters">Range resolution, in meters </param>     
        [ObsoleteAttribute("This method is obsolete.", false)]
        public void SetRangeResolution(float resolution_in_meters)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetRangeResolution(_handle, resolution_in_meters);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Set the requested out image size
        /// The processing code will attempt to process images at the specified size.
        /// However, it doesn't guarantee that the final output will match this size.
        /// NOTE: For R-Theta images, only the width is used, and the image will
        /// be created with that exact width. Height will depend on the range,
        /// and the resolution set. (See SetImageRes() and SetRangeResolution())
        /// </summary>
        /// <param name="height">The requested height </param>
        /// <param name="width">The requested width </param>        
        [ObsoleteAttribute("This method is obsolete.", false)]
        public void SetImageReqSize(int height, int width)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetImageReqSize(_handle, height, width);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the XY dimensions
        /// </summary>
        /// <param name="height">height in pixels </param>
        /// <param name="width">width in pixels </param>        
        [ObsoleteAttribute("This method is obsolete.", false)]
        public void GetXYImageSizeRequested(out int height, out int width)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_GetXYImageSizeRequested(_handle, out height, out width);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Set the XY image size
        /// This is a helper function to accompany the Ping's GetImageXY() function.
        /// </summary>
        /// <param name="width">The requested width </param>
        /// <param name="height">The requested height </param>      
        [ObsoleteAttribute("This method is obsolete.", false)]
        public void SetXYImageSize(int width, int height)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetXYImageSize(_handle, width, height);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Set the RTheta image width
        /// This is a helper function to accompany the Ping's GetImageRTheta() function.
        /// </summary>
        /// <param name="width">The requested width </param>        
        [ObsoleteAttribute("This method is obsolete.", false)]
        public void SetRThetaImageWidth(int width)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetRThetaImageWidth(_handle, width);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Set the type of image created by the BVTPing_GetImage() function.
        /// NOTE: See SetImageReqSize() for important issues regarding image size.
        /// If images are requested with the BVTPing_GetXYImage() or 
        /// BVTPing_GetRThetaImage(), then this function is not needed.
        /// </summary>
        /// <param name="type">Image type constant (IMAGETYPE_*) </param>       
        [ObsoleteAttribute("This method is obsolete.", false)]
        public void SetImageType(ImageType type)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetImageType(_handle, ((int) type));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the filter flags.  As of this version, if more than one flag is set, only the lowest-valued flag is used.
        /// </summary>
        /// <returns>The image filter flags in effect. </returns>       
        [ObsoleteAttribute("This property is obsolete.", false)]
        public ImageFilterFlags ImageFilterFlags
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int flags;
                int error_code = NativeMethods.BVTHead_GetImageFilterFlags(_handle, out flags);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return (ImageFilterFlags) flags;
            }
        }

        /// <summary>
        /// Set the filter flags. As of this version, if more than one flag is set, only the lowest-valued flag is used.
        /// </summary>
        /// <param name="flags">The image filter flags to set (bit field). </param>     
        [ObsoleteAttribute("This method is obsolete.", false)]
        public void SetImageFilterFlags(ImageFilterFlags flags)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetImageFilterFlags(_handle, ((int) flags));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Inform the user about which type of image processing algorithm is being used.
        /// The returned value will correspond to one of the IMAGE_PROCESSING_METHOD_* constants.
        /// </summary>
        /// <returns>The image processing method used by this Head. </returns>      
        [ObsoleteAttribute("This property is obsolete.", false)]
        public ImageProcessingMethod ImageProcessingMethod
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int method;
                int error_code = NativeMethods.BVTHead_GetImageProcessingMethod(_handle, out method);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return (ImageProcessingMethod) method;
            }
        }

        /// <summary>
        /// Return the current image calibration value A.
        /// </summary>
        /// <returns>Undocumented. </returns>       
        [ObsoleteAttribute("This property is obsolete.", false)]
        public int ImageCalibrationA
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int cal_value_a;
                int error_code = NativeMethods.BVTHead_GetImageCalibrationA(_handle, out cal_value_a);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return cal_value_a;
            }
        }

        /// <summary>
        /// Set the image calibration value for A.
        /// This function should only be used for older sonars.  Before using this function,
        /// call @ref ImageProcessingMethod and test the return value.  If the return
        /// value is IMAGE_PROCESSING_METHOD_A (0), then this function may be used, otherwise, do not
        /// use this function.
        /// NOTE: These values will be permanently saved on the sonar,
        /// and the sonar's FLASH memory has limited write cycles available,
        /// so this function should not be called often.
        /// </summary>
        /// <param name="cal_value_a">Undocumented. </param>        
        [ObsoleteAttribute("This method is obsolete.", false)]
        public void SetImageCalibrationA(int cal_value_a)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetImageCalibrationA(_handle, cal_value_a);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the current image calibration value B.
        /// </summary>
        /// <returns>Undocumented. </returns>       
        [ObsoleteAttribute("This property is obsolete.", false)]
        public int ImageCalibrationB
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int cal_value_b;
                int error_code = NativeMethods.BVTHead_GetImageCalibrationB(_handle, out cal_value_b);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return cal_value_b;
            }
        }

        /// <summary>
        /// Set the image calibration value for B.
        /// This function should only be used for older sonars.  Before using this function,
        /// call  @ref ImageProcessingMethod() and test the return value.  If the return
        /// value is IMAGE_PROCESSING_METHOD_A (0), then this function may be used, otherwise, do not
        /// use this function.
        /// NOTE: These values will be permanently saved on the sonar,
        /// and the sonar's FLASH memory has limited write cycles available,
        /// so this function should not be called often.
        /// </summary>
        /// <param name="cal_value_b">Undocumented. </param>        
        [ObsoleteAttribute("This method is obsolete.", false)]
        public void SetImageCalibrationB(int cal_value_b)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetImageCalibrationB(_handle, cal_value_b);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// By default, the sonar transmits pings.  This function allows the user to 
        /// disable transmit.  This can be useful to get background noise measurements.
        /// Note that this is not implemented on all sonars.
        /// </summary>
        /// <param name="enableTx">If 0, disable the sonar transmission of pings.</param>       
        public void SetTxEnable(int enableTx)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetTxEnable(_handle, enableTx);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Stores a copy of the Orientation data with the in the head's MountingOrientation object, so the data
        /// will be saved if the head is saved to a file.
        /// </summary>
        /// <param name="orient">Orientation data object to copy from </param>      
        public void SetMountingOrientation(Orientation orient)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetMountingOrientation(_handle, orient.Handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Retrieves a copy of the MountingOrientation object stored with this head. Note
        /// that the data is copied out of the head into the local Orientation object,
        /// a pointer to internal data is not returned. Thus, the Orientation object
        /// may be used after the head is destroyed.
        /// </summary>
        /// <returns>Orientation data object to copy the existing Orientation data to </returns>        
        public Orientation GetMountingOrientationCopy()
        {
            IntPtr orient_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_GetMountingOrientationCopy(_handle, ref orient_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            Orientation orient = new Orientation(orient_ptr);
            return orient;
        }

        /// <summary>
        /// Stores a copy of the Orientation data with the in the head's MountingOrientation object, so the data
        /// will be saved if the head is saved to a file.
        /// This second (auxillary) Orientation object is optional. 
        /// </summary>
        /// <param name="orient">Orientation data object to copy from </param>      
        public void SetAuxMountingOrientation(Orientation orient)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetAuxMountingOrientation(_handle, orient.Handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Retrieves a copy of the MountingOrientation object stored with this head. Note
        /// that the data is copied out of the head into the local Orientation object,
        /// a pointer to internal data is not returned. Thus, the Orientation object
        /// may be used after the head is destroyed.
        /// This second (auxillary) Orientation object is optional.  Calling this function on an unused auxillary Orientation will return all zeros. 
        /// </summary>
        /// <returns>Orientation data object to copy the existing Orientation data to </returns>        
        public Orientation GetAuxMountingOrientationCopy()
        {
            IntPtr orient_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_GetAuxMountingOrientationCopy(_handle, ref orient_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            Orientation orient = new Orientation(orient_ptr);
            return orient;
        }

        /// <summary>
        /// Return the number of transducers for this head
        /// </summary>
        /// <returns>number of trandsucers</returns>        
        public int TransducerCount
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int count;
                int error_code = NativeMethods.BVTHead_GetTransducerCount(_handle, out count);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return count;
            }
        }

        /// <summary>
        /// Get the transducer orientation for the specified transducer index.
        /// </summary>
        /// <param name="transducer_index">The zero-based index of the transducer</param>
        /// <returns>The orientation of the transducer. </returns>      
        public Orientation GetTransducerOrientationCopy(int transducer_index)
        {
            IntPtr orient_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_GetTransducerOrientationCopy(_handle, transducer_index, ref orient_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            Orientation orient = new Orientation(orient_ptr);
            return orient;
        }

        /// <summary>
        /// Identifies the general configuration of how this data was collected.
        /// </summary>
        /// <param name="type">One of the MOUNTTYPE_* constants </param>        
        public void SetMountType(MountType type)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetMountType(_handle, ((int) type));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the mount type.  The returned value will correspond to
        /// one of the MOUNTTYPE_* constants.
        /// </summary>
        /// <returns>mount type</returns>       
        public MountType MountType
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int type;
                int error_code = NativeMethods.BVTHead_GetMountType(_handle, out type);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return (MountType) type;
            }
        }

        /// <summary>
        /// Specifiy where the sonar was mounted when this data was collected.
        /// </summary>
        /// <param name="side">One of the MOUNTSIDE_* constants </param>        
        public void SetMountSide(MountSide side)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetMountSide(_handle, ((int) side));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return where the sonar was mounted when this data was collected.
        /// The returned value will correspond to one of the SIDE_* constants.
        /// </summary>
        /// <returns>One of the MOUNTSIDE_* constants </returns>        
        public MountSide MountSide
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int side;
                int error_code = NativeMethods.BVTHead_GetMountSide(_handle, out side);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return (MountSide) side;
            }
        }

        /// <summary>
        /// This offset is calculated as MRU time - Sonar time;
        /// </summary>
        /// <param name="milliseconds">Offset in milliseconds between the MRU's time reading and the Sonar's time reading. </param>     
        public void SetMRUTimeOffset(int milliseconds)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetMRUTimeOffset(_handle, milliseconds);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// This offset is calculated as MRU time - Sonar time;
        /// </summary>
        /// <returns>Offset in milliseconds between the MRU's time reading and the Sonar's time reading. </returns>     
        public int MRUTimeOffset
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int milliseconds;
                int error_code = NativeMethods.BVTHead_GetMRUTimeOffset(_handle, out milliseconds);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return milliseconds;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="bearing">Bearing in degrees from pole mount to GPS antenna. </param>
        /// <param name="distance">Distance in meters from pole mount to GPS antenna. </param>      
        public void SetPoleGPSBearing(float bearing, float distance)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetPoleGPSBearing(_handle, bearing, distance);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="bearing">Bearing in degrees from pole mount to GPS antenna. </param>
        /// <param name="distance">Distance in meters from pole mount to GPS antenna. </param>      
        public void GetPoleGPSBearing(out float bearing, out float distance)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_GetPoleGPSBearing(_handle, out bearing, out distance);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="bearing">Bearing in degrees from pole mount to landmark. </param>      
        public void SetPoleLandmarkBearing(float bearing)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetPoleLandmarkBearing(_handle, bearing);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns bearing in degrees from pole mount to landmark. 
        /// </summary>      
        public float PoleLandmarkBearing
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                return NativeMethods.BVTHead_GetPoleLandmarkBearing(_handle);
            }
        }

        /// <summary>
        /// This is used in tripod mount situations where the default/baseline/normal/center
        /// position of the Head is not aligned with the tripod-mounted compass's
        /// North direction.
        /// This offset is calculated as MRU time - Sonar time;         
        /// </summary>
        /// <param name="offset">Offset in degrees from compass North. </param>     
        public void SetHeadingOffset(float offset)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetHeadingOffset(_handle, offset);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns offset in degrees from compass North. 
        /// This is used in tripod mount situations where the default/baseline/normal/center
        /// position of the Head is not aligned with the tripod-mounted compass's
        /// North direction.
        /// </summary>
        /// <returns>heading offset</returns>       
        public float HeadingOffset
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                float offset;
                int error_code = NativeMethods.BVTHead_GetHeadingOffset(_handle, out offset);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return offset;
            }
        }

        /// <summary>
        /// This is used to compute x,y,z offsets driven by the tilt position.
        /// The manufacturer and model strings are limited to a maximum of 79 characters, not counting the terminating null characters.
        /// </summary>
        /// <param name="manufacturer">Manufacturer of pan/tilt unit e.g. ROS </param>
        /// <param name="model">pan/tilt model  </param>
        /// <param name="elbowOffset">offset from tilt motor axis to center of sonar </param>       
        public void SetPanTiltAttributes(string manufacturer, string model, float elbowOffset)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetPanTiltAttributes(_handle, BVTSDK.InteropHelpers.StringToUtf8Ptr(manufacturer), BVTSDK.InteropHelpers.StringToUtf8Ptr(model), elbowOffset);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the name of the Pan-Tilt manufacturer as a string.
        /// </summary>
        /// <returns>The buffer to hold the returned manufacturer name string. </returns>       
        public string PanTiltManufacturer
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                byte[] manufacturer = new byte[256];
                int buffer_length = 255;
                int error_code = NativeMethods.BVTHead_GetPanTiltManufacturer(_handle, manufacturer, buffer_length);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return BVTSDK.InteropHelpers.Utf8ToString(manufacturer);
            }
        }

        /// <summary>
        /// Returns the length of the name of the Pan-Tilt manufacturer as a string.
        /// </summary>
        /// <returns>The size in characters of the manufacturer name string. </returns>     
        public int PanTiltManufacturerLength
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int buffer_length;
                int error_code = NativeMethods.BVTHead_GetPanTiltManufacturerLength(_handle, out buffer_length);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return buffer_length;
            }
        }

        /// <summary>
        /// Returns the model name.
        /// </summary>
        /// <returns>The string to hold the returned model name. </returns>     
        public string PanTiltModel
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                byte[] model = new byte[256];
                int buffer_length = 255;
                int error_code = NativeMethods.BVTHead_GetPanTiltModel(_handle, model, buffer_length);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return BVTSDK.InteropHelpers.Utf8ToString(model);
            }
        }

        /// <summary>
        /// Returns the length of the model name.
        /// </summary>
        /// <returns>The string length of the model name. </returns>        
        public int PanTiltModelLength
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                int buffer_length;
                int error_code = NativeMethods.BVTHead_GetPanTiltModelLength(_handle, out buffer_length);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return buffer_length;
            }
        }

        /// <summary>
        /// This is used to compute x,y,z offsets driven by the tilt position. Elbow offset specified in meters
        /// </summary>
        /// <returns>offset to P/T elbow </returns>     
        public float PanTiltElbowOffset
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTHead");
                float offset;
                int error_code = NativeMethods.BVTHead_GetPanTiltElbowOffset(_handle, out offset);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return offset;
            }
        }

        /// <summary>
        /// Helper function to retrieve the pan/tilt mount offsets.  
        /// The panRotationOffset and tiltRotationOffset values should be subtracted 
        /// from the X_axis_degrees (pan) and Y_axis_degrees (tilt) parameters 
        /// of the BVTPing_GetPositionerRotations() function to obtain 
        /// the same pan & tilt values displayed during data collection.
        /// If verticalInverted is false(0), then the tilt value obtained in the 
        /// step above must be multiplied by -1.0 to represent real-world tilt values.
        /// </summary>
        /// <param name="tiltElbowVerticalOffset">in meters </param>
        /// <param name="tiltElbowHorizontalOffset">in meters </param>
        /// <param name="panRotationOffset">offset to "home" position </param>
        /// <param name="tiltRotationOffset">offset to "home" position </param>
        /// <param name="verticalInverted">either 1 or 0, to indicate true or false, respectively </param>      
        public void GetPanTiltMountOffsets(out float tiltElbowVerticalOffset, out float tiltElbowHorizontalOffset, out float panRotationOffset, out float tiltRotationOffset, out int verticalInverted)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_GetPanTiltMountOffsets(_handle, out tiltElbowVerticalOffset, out tiltElbowHorizontalOffset, out panRotationOffset, out tiltRotationOffset, out verticalInverted);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Helper function to set the pan/tilt mount offsets.  
        /// The panRotationOffset and tiltRotationOffset values should be subtracted 
        /// from the X_axis_degrees (pan) and Y_axis_degrees (tilt) parameters 
        /// of the BVTPing_GetPositionerRotations() function to obtain 
        /// the same pan & tilt values displayed during data collection.
        /// verticalInverted is set to false(0) if the pan/tilt device has been mounted in an inverted fashion.
        /// </summary>
        /// <param name="tiltElbowVerticalOffset">in meters </param>
        /// <param name="tiltElbowHorizontalOffset">in meters </param>
        /// <param name="panRotationOffset">offset to "home" position </param>
        /// <param name="tiltRotationOffset">offset to "home" position </param>
        /// <param name="verticalInverted">either 1 or 0, to indicate true or false, respectively </param>      
        public void SetPanTiltMountOffsets(float tiltElbowVerticalOffset, float tiltElbowHorizontalOffset, float panRotationOffset, float tiltRotationOffset, int verticalInverted)
        {
            if (_disposed) throw new ObjectDisposedException("BVTHead");
            int error_code = NativeMethods.BVTHead_SetPanTiltMountOffsets(_handle, tiltElbowVerticalOffset, tiltElbowHorizontalOffset, panRotationOffset, tiltRotationOffset, verticalInverted);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }


        /// SDK object pointer
        internal HandleRef Handle
        {
            get { return _handle; }
        }
        private readonly HandleRef _handle;

        private bool _disposed;

        public Sonar Sonar
        {
            get { return _parent; }
        }
        /// A strong reference to an SDK object owner,
        /// required to prevent premature finalization of the owner
        private readonly Sonar _parent;

        /// P/Invoke 'wrapper' class
        private static class NativeMethods
        {
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern IntPtr BVTHead_Destroy(HandleRef obj);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetHeadID(HandleRef obj, out int headId);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetHeadName(HandleRef obj, byte[] buffer, int buffer_size);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetHeadName(HandleRef obj, byte[] name);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetRange(HandleRef obj, float start, float stop);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetStartRange(HandleRef obj, out float start);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetStopRange(HandleRef obj, out float stop);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetMinimumRange(HandleRef obj, out float range);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetMaximumRange(HandleRef obj, out float range);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetStartRange(HandleRef obj, float start);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetStopRange(HandleRef obj, float stop);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetClippingThreshold(HandleRef obj, int threshold);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetClippingThreshold(HandleRef obj, out int threshold);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_EnableClippingThreshold(HandleRef obj, int enable);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetFluidType(HandleRef obj, out int fluidType);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetFluidType(HandleRef obj, int fluid);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetSoundSpeed(HandleRef obj, out int speed);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetSoundSpeed(HandleRef obj, int speed);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetGainAdjustment(HandleRef obj, out float gain);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetGainAdjustment(HandleRef obj, float gain);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetTVGSlope(HandleRef obj, out float slope);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetTVGSlope(HandleRef obj, float tvg);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetDynamicPowerManagement(HandleRef obj, out int is_enabled);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetDynamicPowerManagement(HandleRef obj, int enable);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SupportsAlternatePingMode(HandleRef obj, out int is_supported);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetAlternatePingModeEnabled(HandleRef obj, int enabled);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetAlternatePingModeEnabled(HandleRef obj, out int enabled);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetCenterFreq(HandleRef obj, out int frequency);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetPingCount(HandleRef obj, out int count);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetPing(HandleRef obj, int ping_num, ref IntPtr ping);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetPingMetadataOnly(HandleRef obj, int ping_num, ref IntPtr ping);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetPingMulticast(HandleRef obj, int ping_num, ref IntPtr ping);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_ListenForPingMulticast(HandleRef obj, ref IntPtr ping);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_PutPing(HandleRef obj, HandleRef source_ping);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetPingInterval(HandleRef obj, int milliseconds);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetPingInterval(HandleRef obj, out int milliseconds);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetImageRes(HandleRef obj, int res);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetRangeResolution(HandleRef obj, float resolution_in_meters);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetImageReqSize(HandleRef obj, int height, int width);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetXYImageSizeRequested(HandleRef obj, out int height, out int width);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetXYImageSize(HandleRef obj, int width, int height);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetRThetaImageWidth(HandleRef obj, int width);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetImageType(HandleRef obj, int type);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetImageFilterFlags(HandleRef obj, out int flags);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetImageFilterFlags(HandleRef obj, int flags);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetImageProcessingMethod(HandleRef obj, out int method);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetImageCalibrationA(HandleRef obj, out int cal_value_a);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetImageCalibrationA(HandleRef obj, int cal_value_a);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetImageCalibrationB(HandleRef obj, out int cal_value_b);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetImageCalibrationB(HandleRef obj, int cal_value_b);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetTxEnable(HandleRef obj, int enableTx);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetMountingOrientation(HandleRef obj, HandleRef orient);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetMountingOrientationCopy(HandleRef obj, ref IntPtr orient);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetAuxMountingOrientation(HandleRef obj, HandleRef orient);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetAuxMountingOrientationCopy(HandleRef obj, ref IntPtr orient);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetTransducerCount(HandleRef obj, out int count);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetTransducerOrientationCopy(HandleRef obj, int transducer_index, ref IntPtr orient);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetMountType(HandleRef obj, int type);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetMountType(HandleRef obj, out int type);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetMountSide(HandleRef obj, int side);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetMountSide(HandleRef obj, out int side);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetMRUTimeOffset(HandleRef obj, int milliseconds);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetMRUTimeOffset(HandleRef obj, out int milliseconds);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetPoleGPSBearing(HandleRef obj, float bearing, float distance);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetPoleGPSBearing(HandleRef obj, out float bearing, out float distance);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetPoleLandmarkBearing(HandleRef obj, float bearing);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern float BVTHead_GetPoleLandmarkBearing(HandleRef obj);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetHeadingOffset(HandleRef obj, float offset);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetHeadingOffset(HandleRef obj, out float offset);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetPanTiltAttributes(HandleRef obj, byte[] manufacturer, byte[] model, float elbowOffset);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetPanTiltManufacturer(HandleRef obj, byte[] manufacturer, int buffer_length);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetPanTiltManufacturerLength(HandleRef obj, out int buffer_length);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetPanTiltModel(HandleRef obj, byte[] model, int buffer_length);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetPanTiltModelLength(HandleRef obj, out int buffer_length);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetPanTiltElbowOffset(HandleRef obj, out float offset);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_GetPanTiltMountOffsets(HandleRef obj, out float tiltElbowVerticalOffset, out float tiltElbowHorizontalOffset, out float panRotationOffset, out float tiltRotationOffset, out int verticalInverted);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTHead_SetPanTiltMountOffsets(HandleRef obj, float tiltElbowVerticalOffset, float tiltElbowHorizontalOffset, float panRotationOffset, float tiltRotationOffset, int verticalInverted);

        }
    }

}
