///
/// This file has been generated by bvtidl.pl. DO NOT MODIFY!
///

using System;
using System.Runtime.InteropServices;


namespace BVTSDK
{
/// <summary>
/// As its name implies, the Ping object represents the return from 
/// a single ping on a particular head. <br>
/// A ping is essentially a container for data. As such, after you get
/// a ping from the head and extract the data (or save it to a file),
/// it is necessary to destroy the ping object to free up memory. <br>
/// Each ping may also store navigation data to indicate the position
/// and orientation of the vehicle at the time of the ping. <br>
/// Each ping may have a video frame associated with it, and saved in
/// the same file. These images are typically from a video camera
/// mounted near the sonar, such as on a ROV. <br>
/// </summary>
    public class Ping : IDisposable
    {
        internal Ping(Head parent, IntPtr p)
        {
            _handle = new HandleRef(this, p);
            _parent = parent;
        }

        internal Ping(IntPtr p)
        {
            _handle = new HandleRef(this, p);
        }

        /// Non-deterministic destruction of this object on the Finalizer thread
        ~Ping()
        {
            Dispose(false);
        }

        /// Dispose deterministically
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;
            _disposed = true;
            NativeMethods.BVTPing_Destroy(_handle);
        }

        /// <summary>
        /// Creates and returns a copy of this ping.
        /// \attention Don't forget to call Destroy on the returned copy.
        /// </summary>
        /// <returns>A copy of this ping. </returns>        
        public Ping Copy()
        {
            IntPtr the_copy_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_Copy(_handle, ref the_copy_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            Ping the_copy = new Ping(this._parent, the_copy_ptr);
            return the_copy;
        }

        /// <summary>
        /// Change the range window of this ping by removing data from the start or the end of the received singnal.
        /// \attention This will fail if you try to decrease the existing start range or increase the existing stop range
        /// </summary>
        /// <param name="new_start">The new start range in meters </param>
        /// <param name="new_stop">The new stop range in meters </param>        
        public void AdjustRange(float new_start, float new_stop)
        {
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_AdjustRange(_handle, new_start, new_stop);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the ping number (i.e., index in file).
        /// Ping numbers only have meaning if the ping came from a file.
        /// </summary>
        /// <returns>ping number </returns>     
        public int PingNumber
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTPing");
                int number;
                int error_code = NativeMethods.BVTPing_GetPingNumber(_handle, out number);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return number;
            }
        }

        /// <summary>
        /// Return the head ID this ping was captured, or saved with.
        /// </summary>
        /// <returns>head id</returns>      
        public int HeadID
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTPing");
                int id;
                int error_code = NativeMethods.BVTPing_GetHeadID(_handle, out id);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return id;
            }
        }

        /// <summary>
        /// Return the ping's timestamp in seconds since 00:00:00 UTC, January 1, 1970 
        /// Pings are timestamped using a standard UNIX time stamp. This is 
        /// a similar value to that returned by the time() C standard library 
        /// function. In fact, the only difference is the addition of fractional seconds.
        /// </summary>
        /// <returns>ping timestamp</returns>       
        public double Timestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTPing");
                double timestamp;
                int error_code = NativeMethods.BVTPing_GetTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// Return the ping's timestamp's offset in seconds from UTC time.  Add this value to that returned by Timestamp() to obtain UTC time.
        /// </summary>
        /// <returns>timezone offset</returns>      
        public int TimeZoneOffset
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTPing");
                int offset;
                int error_code = NativeMethods.BVTPing_GetTimeZoneOffset(_handle, out offset);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return offset;
            }
        }

        /// <summary>
        /// Set the ping's internal time stamp.  See Timestamp() for more information. 
        /// Note: BlueView strongly recommends that users NOT directly set the time stamp as 
        /// it is set internally when the ping is actually initiated.  If you are trying to 
        /// synchronize two systems, it is far better to simply make sure that the system
        /// clocks are synchronized, as the ping timestamp is created from the 
        /// PC's internal clock. Network Time Protocol and GPS sources provide highly 
        /// accurate ways to accomplish this.
        /// Caution: This also overwrites the ping's recorded time zone offset with the client operating system's time zone offset.
        /// Call SetTimeZoneOffset after SetTimestamp if you need to maintain the original offset.
        /// </summary>
        /// <param name="sec">Timestamp in seconds since 00:00:00 UTC, January 1, 1970 </param>     
        public void SetTimestamp(double sec)
        {
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_SetTimestamp(_handle, sec);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Set the ping's time zone offset in seconds from UTC time.
        /// </summary>
        /// <param name="timeZoneOffset">The timestamp's offset in seconds from UTC time. </param>      
        public void SetTimeZoneOffset(int timeZoneOffset)
        {
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_SetTimeZoneOffset(_handle, timeZoneOffset);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Retrieve the angular limits of the ping's field-of-view. Note that the limits
        /// reported represent only the minimum and maximum angles associated with any
        /// pixel in the FOV. It is possible (depending on sonar configuration) that not
        /// all pixels within the reported field-of-view are populated with data.
        /// </summary>
        /// <param name="minAngleInDegrees">minimum angle in the ping's field-of-view</param>
        /// <param name="maxAngleInDegrees">maximum angle in the ping's field-of-view</param>       
        public void GetFOV(out float minAngleInDegrees, out float maxAngleInDegrees)
        {
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_GetFOV(_handle, out minAngleInDegrees, out maxAngleInDegrees);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the ping's the start range in meters.
        /// </summary>
        /// <returns>This ping's start range in meters </returns>       
        public float StartRange
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTPing");
                float range;
                int error_code = NativeMethods.BVTPing_GetStartRange(_handle, out range);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return range;
            }
        }

        /// <summary>
        /// Return the stop range in meters.
        /// </summary>
        /// <returns>This ping's stop range in meters </returns>        
        public float StopRange
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTPing");
                float range;
                int error_code = NativeMethods.BVTPing_GetStopRange(_handle, out range);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return range;
            }
        }

        /// <summary>
        /// Return the sound speed this ping was recorded at
        /// </summary>
        /// <returns>the current speed of sound in water for this ping in meters per second </returns>      
        public int SoundSpeed
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTPing");
                int sound_speed;
                int error_code = NativeMethods.BVTPing_GetSoundSpeed(_handle, out sound_speed);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return sound_speed;
            }
        }

        /// <summary>
        /// Retrieve an image of this ping, according to the parameters set
        /// in the head used to get this ping. See Head and MagImage documentation
        /// for more details.
        /// </summary>
        /// <returns>image </returns>       
        [ObsoleteAttribute("This method is obsolete.", false)]
        public MagImage GetImage()
        {
            IntPtr img_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_GetImage(_handle, ref img_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            MagImage img = new MagImage(img_ptr);
            return img;
        }

        /// <summary>
        /// Retrieve an XY-format image of this ping, according to the parameters set
        /// in the head used to get this ping. Use BVTHead_SetImageSizeXY() to set the size for this image.
        /// See Head and MagImage documentation for more details.
        /// </summary>
        /// <returns>image </returns>       
        [ObsoleteAttribute("This method is obsolete.", false)]
        public MagImage GetImageXY()
        {
            IntPtr img_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_GetImageXY(_handle, ref img_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            MagImage img = new MagImage(img_ptr);
            return img;
        }

        /// <summary>
        /// Retrieve an RTheta-format image of this ping, according to the parameters set
        /// in the head used to get this ping. Use BVTHead_SetImageWidthRTheta() to set the size for this image.
        /// See Head and MagImage documentation for more details.
        /// </summary>
        /// <returns>image </returns>       
        [ObsoleteAttribute("This method is obsolete.", false)]
        public MagImage GetImageRTheta()
        {
            IntPtr img_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_GetImageRTheta(_handle, ref img_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            MagImage img = new MagImage(img_ptr);
            return img;
        }

        /// <summary>
        /// Returns the percentage of dyn. range (0.0 - 1.0) of the max value in this
        /// ping. A value of 1.0 indicates clipped data. A value near 0.0 indicates 
        /// that no targets were illuminated.
        /// </summary>
        /// <returns>max return signal </returns>       
        public float MaxReturnSignal
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTPing");
                float max;
                int error_code = NativeMethods.BVTPing_GetMaxReturnSignal(_handle, out max);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return max;
            }
        }

        /// <summary>
        /// Creates a copy of the navigation data stored with this ping. Note
        /// that the data is copied out of the ping into the local NavData object,
        /// a pointer to internal data is not returned. Thus, the NavData object
        /// may be used after the Ping is destroyed.
        /// </summary>
        /// <returns>A copy of the NavData stored in this object. </returns>        
        public NavData GetNavDataCopy()
        {
            IntPtr nav_data_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_GetNavDataCopy(_handle, ref nav_data_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            NavData nav_data = new NavData(nav_data_ptr);
            return nav_data;
        }

        /// <summary>
        /// Creates a copy of the navigation data stored with this ping. Note
        /// that the data is copied out of the ping into the local NavData object,
        /// a pointer to internal data is not returned. Thus, the NavData object
        /// may be used after the Ping is destroyed.
        /// </summary>
        /// <returns>A copy of the NavData stored in this object. </returns>        
        public bool TryGetNavDataCopy(out NavData nav_data)
        {
            IntPtr nav_data_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_GetNavDataCopy(_handle, ref nav_data_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                nav_data = null;
                return false;
            }
            nav_data = new NavData(nav_data_ptr);
            return true;
        }

        /// <summary>
        /// Returns true if this ping has a valid Navigation data object.
        /// </summary>
        /// <returns>True if this ping has a valid Navigation data object </returns>        
        public bool HasNavData
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTPing");
                int has_nav_data;
                int error_code = NativeMethods.BVTPing_HasNavData(_handle, out has_nav_data);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return has_nav_data > 0;
            }
        }

        /// <summary>
        /// Stores a copy of the navigation data with the other ping data, so the data
        /// will be saved if the ping is saved to a file.
        /// </summary>
        /// <param name="nav_data">Navigation data object to copy into this Ping </param>       
        public void SetNavData(NavData nav_data)
        {
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_SetNavData(_handle, nav_data.Handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Video frame is raw RGB (RGBRGB...) 
        /// </summary>
        public const int VIDEO_RGB = 0;

        /// <summary>
        /// Video frame is a JPEG image 
        /// </summary>
        public const int VIDEO_JPEG = 1;

        /// <summary>
        /// Returns the video frame associated with this ping.
        /// The video frame may be in any of the supported image formats.
        /// Some image formats may already contain parameters such as height
        /// and width (and more), but valid pointers must be passed in anyway.
        /// The same pointer can be passed in for multiple parameters, if
        /// those parameters will not be used. However, they are provided both
        /// for formats which do not have embedded size information, and so that
        /// the display window may be created and/or sized without parsing
        /// the image data.<br>
        /// NOTE: This function will return BVT_NO_VIDEO_FRAME if there
        /// is no video frame stored for the ping. <br>
        /// WARNING: The data buffer must NOT be accessed after the ping object is destroyed,
        /// as the pointer will no longer point to valid data and will likely crash your application!
        /// So copy off the data before destroying the Ping object. <br>
        /// The single value pointers must be pointers to allocated data, not just
        /// pointer types. For example:<br>
        /// int height, width, length, type, retval;<br>
        /// int * frame_ptr;<br>
        /// retval = GetVideoFrame( frame_ptr, &height, &width, &length, &type );<br>
        /// </summary>
        /// <param name="frame">Pointer to a pointer to the image data to be returned </param>
        /// <param name="height">Pointer to return the uncompressed height of the image, in pixels </param>
        /// <param name="width">Pointer to return the uncompressed width of the image, in pixels </param>
        /// <param name="length">Pointer to return the actual size of the data buffer returned, in bytes, which may include additional metadata for some image types </param>
        /// <param name="type">pointer to return the type of image returned: FRAME_RGB or FRAME_JPEG </param>       
        public void GetVideoFrame(out byte[] frame, out int height, out int width, out int length, out int type)
        {
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_GetVideoFrame(_handle, out frame, out height, out width, out length, out type);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Store a JPEG image to save with this ping.
        /// Note that the height and width values will simply be stored and
        /// available to read when the frame is retrieved. These have no effect
        /// on the actual image size (the image will not be resized).
        /// The length however is very important, as it determines how far from
        /// the passed image pointer data will be read. An incorrect length could
        /// result in an application crash.
        /// </summary>
        /// <param name="frame">Pointer to a single video frame</param>
        /// <param name="height">Uncompressed height of the image, in pixels </param>
        /// <param name="width">Uncompressed width of the image, in pixels </param>
        /// <param name="length">Actual number of bytes being passed in </param>        
        public void SetVideoFrameJPEG(byte[] frame, int height, int width, int length)
        {
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_SetVideoFrameJPEG(_handle, frame, height, width, length);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Stores a copy of the per ping Positioner Orientation data in the ping, so the data
        /// will be saved if the ping is saved to a file. This orientation object represents
        /// the dynamic position of the head as it is moved via a positioner. Other orientation
        /// information will be needed to determine the absolute position of the head relative
        /// to a larger coordinate system (i.e. the vessel). NOTE: the X rotation represents
        /// side to side panning, and Y rotation represents vertical tilt. (which might be opposite
        /// from previous SDKs; though the older files will be translated to the new convention.)
        /// </summary>
        /// <param name="orient">Orientation data object to copy from </param>      
        public void SetPositionerOrientation(Orientation orient)
        {
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_SetPositionerOrientation(_handle, orient.Handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Retrieves a copy of the per ping Positioner Orientation data which was stored with this ping.,
        /// Note that the data is copied out of the ping into the local Orientation object,
        /// a pointer to internal data is not returned. Thus, the Orientation object
        /// may be used after the Ping is destroyed. (see SetPositionerOrientation, above, for more
        /// information on the meaning of the PositionerOrientation data)
        /// </summary>
        /// <returns>Orientation data object to copy the existing Orientation data to </returns>        
        public Orientation GetPositionerOrientationCopy()
        {
            IntPtr orient_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_GetPositionerOrientationCopy(_handle, ref orient_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            Orientation orient = new Orientation(orient_ptr);
            return orient;
        }

        /// <summary>
        /// Simplified function to set just the rotations from the Ping's PositionerOrientation object.
        /// The offsets and calibration values will be zero. The source and target frames will be set to
        /// OR_POSITIONER and OR_HEAD, respectively.
        /// This function is most useful when only pan/tilt values are available and needed.
        /// See the SetPositionerOrientation() documentation for more details.
        /// </summary>
        /// <param name="X_axis_degrees">pan axis rotation </param>
        /// <param name="Y_axis_degrees">tilt axis rotation </param>
        /// <param name="Z_axis_degrees">not currently used </param>        
        public void SetPositionerRotations(double X_axis_degrees, double Y_axis_degrees, double Z_axis_degrees)
        {
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_SetPositionerRotations(_handle, X_axis_degrees, Y_axis_degrees, Z_axis_degrees);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Simplified function to get just the rotations from the Ping's PositionerOrientation object.
        /// </summary>
        /// <param name="X_axis_degrees">pan axis rotation </param>
        /// <param name="Y_axis_degrees">tilt axis rotation </param>
        /// <param name="Z_axis_degrees">not currently used </param>        
        public void GetPositionerRotations(out double X_axis_degrees, out double Y_axis_degrees, out double Z_axis_degrees)
        {
            if (_disposed) throw new ObjectDisposedException("BVTPing");
            int error_code = NativeMethods.BVTPing_GetPositionerRotations(_handle, out X_axis_degrees, out Y_axis_degrees, out Z_axis_degrees);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns true if this ping has a raw time series.
        /// </summary>
        /// <returns>True if this ping has a raw time series. </returns>        
        public bool HasSignal
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTPing");
                int has_signal;
                int error_code = NativeMethods.BVTPing_HasSignal(_handle, out has_signal);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return has_signal > 0;
            }
        }

        /// <summary>
        /// Returns true if this ping has a post-processed profile.
        /// </summary>
        /// <returns>True if this ping has a post-processed profile. </returns>     
        public bool HasStoredRangeProfile
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTPing");
                int has_stored_profile;
                int error_code = NativeMethods.BVTPing_HasStoredRangeProfile(_handle, out has_stored_profile);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return has_stored_profile > 0;
            }
        }


        /// SDK object pointer
        internal HandleRef Handle
        {
            get { return _handle; }
        }
        private readonly HandleRef _handle;

        private bool _disposed;

        public Head Head
        {
            get { return _parent; }
        }
        /// A strong reference to an SDK object owner,
        /// required to prevent premature finalization of the owner
        private readonly Head _parent;

        /// P/Invoke 'wrapper' class
        private static class NativeMethods
        {
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern IntPtr BVTPing_Destroy(HandleRef obj);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_Copy(HandleRef obj, ref IntPtr the_copy);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_AdjustRange(HandleRef obj, float new_start, float new_stop);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetPingNumber(HandleRef obj, out int number);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetHeadID(HandleRef obj, out int id);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetTimeZoneOffset(HandleRef obj, out int offset);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_SetTimestamp(HandleRef obj, double sec);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_SetTimeZoneOffset(HandleRef obj, int timeZoneOffset);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetFOV(HandleRef obj, out float minAngleInDegrees, out float maxAngleInDegrees);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetStartRange(HandleRef obj, out float range);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetStopRange(HandleRef obj, out float range);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetSoundSpeed(HandleRef obj, out int sound_speed);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetImage(HandleRef obj, ref IntPtr img);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetImageXY(HandleRef obj, ref IntPtr img);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetImageRTheta(HandleRef obj, ref IntPtr img);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetMaxReturnSignal(HandleRef obj, out float max);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetNavDataCopy(HandleRef obj, ref IntPtr nav_data);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_HasNavData(HandleRef obj, out int has_nav_data);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_SetNavData(HandleRef obj, HandleRef nav_data);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetVideoFrame(HandleRef obj, out byte[] frame, out int height, out int width, out int length, out int type);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_SetVideoFrameJPEG(HandleRef obj, byte[] frame, int height, int width, int length);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_SetPositionerOrientation(HandleRef obj, HandleRef orient);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetPositionerOrientationCopy(HandleRef obj, ref IntPtr orient);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_SetPositionerRotations(HandleRef obj, double X_axis_degrees, double Y_axis_degrees, double Z_axis_degrees);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_GetPositionerRotations(HandleRef obj, out double X_axis_degrees, out double Y_axis_degrees, out double Z_axis_degrees);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_HasSignal(HandleRef obj, out int has_signal);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTPing_HasStoredRangeProfile(HandleRef obj, out int has_stored_profile);

        }
    }

}
