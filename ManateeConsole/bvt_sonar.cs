///
/// This file has been generated by bvtidl.pl. DO NOT MODIFY!
///

using System;
using System.Runtime.InteropServices;
using BVTSDK; 


namespace BVTSDK
{
/// <summary>
/// The Sonar object is the top level object in the SDK.  A sonar 
/// object embodies communication with a single physical sonar unit,
/// or file.  Each sonar contains several heads, which is where most
/// of the functionality is implemented.  Sonar also provides a
/// function to create new data files using BlueView's .son format.
/// </summary>
    public class Sonar : IDisposable
    {
        public Sonar()
        {
            IntPtr p = NativeMethods.BVTSonar_Create();
            _handle = new HandleRef(this, p);
        }

        internal Sonar(IntPtr p)
        {
            _handle = new HandleRef(this, p);
        }

        /// Non-deterministic destruction of this object on the Finalizer thread
        ~Sonar()
        {
            Dispose(false);
        }

        /// Dispose deterministically
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;
            _disposed = true;
            NativeMethods.BVTSonar_Destroy(_handle);
        }

        /// <summary>
        /// Open the sonar type 'type' using the specified parameters.
        /// Allowed types (and parameters):
        /// - FILE <br>
        /// [filename] - Required <br>
        /// - NET <br>
        /// [host] - Connect to the specified host.<br>
        /// - CFILE <br>
        /// [files] - semicolon delimited list of files to play as composite sonar<br>
        /// - COMP <br>
        /// [hosts] - semicolon delimited list of files hosts to connect to.
        /// of each host all heads will be used.<br>
        /// </summary>
        /// <param name="type">The type of sonar to open    </param>
        /// <param name="type_params">Various type-specific parameters </param>     
        public void Open(string type, string type_params)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_Open(_handle, BVTSDK.InteropHelpers.StringToUtf8Ptr(type), BVTSDK.InteropHelpers.StringToUtf8Ptr(type_params));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Create a new data file.
        /// Files are always created by 'cloning' another Sonar
        /// object.  This ensures that the file receives all the
        /// needed configuration data needed to process 
        /// images.
        /// </summary>
        /// <param name="file_name">The filename of the file to be created </param>
        /// <param name="src">The Sonar object to clone when creating the file </param>
        /// <param name="create_params">Parameters for (reserved for future use) </param>       
        public void CreateFile(string file_name, Sonar src, string create_params)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_CreateFile(_handle, BVTSDK.InteropHelpers.StringToUtf8Ptr(file_name), src.Handle, BVTSDK.InteropHelpers.StringToUtf8Ptr(create_params));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the serial 'number' of the sonar. The string may contain non-numeric characters.
        /// </summary>
        /// <returns>buffer to hold the null-terminated string to be passed back </returns>     
        public string SerialNumber
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                byte[] buffer = new byte[256];
                int buffer_size = 255;
                int error_code = NativeMethods.BVTSonar_GetSerialNumber(_handle, buffer, buffer_size);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return BVTSDK.InteropHelpers.Utf8ToString(buffer);
            }
        }

        /// <summary>
        /// Return the firmware revision of the sonar. The string may contain non-numeric characters.
        /// </summary>
        /// <returns>buffer to hold the null-terminated string to be passed back </returns>     
        public string FirmwareRevision
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                byte[] buffer = new byte[256];
                int buffer_size = 255;
                int error_code = NativeMethods.BVTSonar_GetFirmwareRevision(_handle, buffer, buffer_size);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return BVTSDK.InteropHelpers.Utf8ToString(buffer);
            }
        }

        /// <summary>
        /// Returns True if this sonar is associated with a file.
        /// </summary>
        /// <returns>True if this sonar is associated with a file </returns>        
        public bool IsFile
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int is_file;
                int error_code = NativeMethods.BVTSonar_IsFile(_handle, out is_file);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return is_file > 0;
            }
        }

        /// <summary>
        /// Returns True if this sonar is networked and connected.
        /// </summary>
        /// <returns>True if this sonar is networked and connected. </returns>      
        public bool IsConnected
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int is_connected;
                int error_code = NativeMethods.BVTSonar_IsConnected(_handle, out is_connected);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return is_connected > 0;
            }
        }

        /// <summary>
        /// Returns True if this sonar is networked and supports multicast pings.
        /// </summary>
        /// <returns>True if this sonar is networked and supports multicast pings </returns>        
        public bool SupportsMulticast
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int is_multicast;
                int error_code = NativeMethods.BVTSonar_SupportsMulticast(_handle, out is_multicast);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return is_multicast > 0;
            }
        }

        /// <summary>
        /// Removes all user settings stored on the sonar and reverts the unit back to
        /// its original factory configuration.  IP address of the unit after calling 
        /// this function will be 192.168.1.45, while other parameters depend on the type of
        /// sonar.
        /// </summary>      
        public void RevertFactorySettings()
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_RevertFactorySettings(_handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Gets the size of a file created with CreateFile(). Only works with
        /// file type sonars. A networked sonar will return 0, as will a file
        /// type sonar if there is no open file associated with it.
        /// The return value must be multiplied by 1000 to get the actual
        /// file size in bytes.
        /// </summary>
        /// <returns>Size (in bytes) of the file sonar</returns>        
        public int FileSize
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int fileSize;
                int error_code = NativeMethods.BVTSonar_GetFileSize(_handle, out fileSize);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return fileSize;
            }
        }

        /// <summary>
        /// Return the number of time indexed pings in this file.
        /// </summary>
        /// <returns>Number of time-indexed pings</returns>     
        public int TimeIndexedPingCount
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int count;
                int error_code = NativeMethods.BVTSonar_GetTimeIndexedPingCount(_handle, out count);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return count;
            }
        }

        /// <summary>
        /// Retrieve a ping from the file, using the time index.
        /// The Ping will have the same Head parent that it was acquired with.
        /// If this function is called on a "live" sonar (network),
        /// then it always returns the FAILED (1) error.
        /// </summary>
        /// <param name="ping_num">The ping number to return </param>
        /// <returns>The returned Ping object</returns>     
        public Ping GetTimeIndexedPing(int ping_num)
        {
            IntPtr ping_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_GetTimeIndexedPing(_handle, ping_num, ref ping_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            Ping ping = new Ping(ping_ptr);
            return ping;
        }

        /// <summary>
        /// Retrieve a Head object from the sonar
        /// </summary>
        /// <param name="head_num">The head number to return </param>
        /// <returns>The returned Head object </returns>        
        public Head GetHead(int head_num)
        {
            IntPtr head_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_GetHead(_handle, head_num, ref head_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            Head head = new Head(this, head_ptr);
            return head;
        }

        /// <summary>
        /// Return the number of heads on this sonar.
        /// </summary>
        /// <returns>Number of heads</returns>      
        public int HeadCount
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int head_count;
                int error_code = NativeMethods.BVTSonar_GetHeadCount(_handle, out head_count);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return head_count;
            }
        }

        /// <summary>
        /// Retrieves a copy of a short string with the model of the sonar.
        /// At the time of this writing, 20 characters would easily hold all of
        /// the sonar model names.
        /// </summary>
        /// <returns>buffer to hold the null-terminated string to be passed back </returns>     
        public string SonarModelName
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                byte[] buffer = new byte[256];
                int buffer_size = 255;
                int error_code = NativeMethods.BVTSonar_GetSonarModelName(_handle, buffer, buffer_size);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return BVTSDK.InteropHelpers.Utf8ToString(buffer);
            }
        }

        /// <summary>
        /// Retrieves a copy of the user-overridable name of the sonar. <br> 
        /// The name is set at the factory but is separate from any BlueView model designations. <br>
        /// </summary>
        /// <returns>buffer to hold the null-terminated string to be passed back </returns>     
        public string SonarName
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                byte[] buffer = new byte[256];
                int buffer_size = 255;
                int error_code = NativeMethods.BVTSonar_GetSonarName(_handle, buffer, buffer_size);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return BVTSDK.InteropHelpers.Utf8ToString(buffer);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="name">buffer with the null-terminated string name to be set. </param>      
        public void SetSonarName(string name)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_SetSonarName(_handle, BVTSDK.InteropHelpers.StringToUtf8Ptr(name));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the sonar's internal temperature in degrees Celsius
        /// </summary>
        /// <returns>temperature</returns>      
        public float GetTemperature()
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            float temperature;
            int error_code = NativeMethods.BVTSonar_GetTemperature(_handle, out temperature);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            return temperature;
        }

        /// <summary>
        /// Return the sonar's internal temperature in degrees Celsius
        /// </summary>
        /// <returns>temperature</returns>      
        public bool TryGetTemperature(out float temperature)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_GetTemperature(_handle, out temperature);
            GC.KeepAlive(this);
            if (0 != error_code)
            {
                temperature = 0.0f;
                return false;
            }
            return true;
        }

        /// <summary>
        /// Write the object to a file.  Note that this object is not associated with a Ping.
        /// </summary>
        /// <param name="nav_data">The Navigation data object to write out </param>     
        public void PutNavData(NavData nav_data)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_PutNavData(_handle, nav_data.Handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the number of NavData objects in this file.  This count does not include any NavData objects that were written to the file as part of a Ping.
        /// </summary>
        /// <returns>NavData count</returns>        
        public int NavDataCount
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int count;
                int error_code = NativeMethods.BVTSonar_GetNavDataCount(_handle, out count);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return count;
            }
        }

        /// <summary>
        /// Retrieve a NavData object from the file.
        /// The index is zero-based, that is, if NavDataCount() returned a value of 3, then valid indices are 0, 1, and 2.
        /// </summary>
        /// <param name="index">index of NavData to return </param>
        /// <returns>The returned NavData object</returns>      
        public NavData GetNavDataCopy(int index)
        {
            IntPtr nav_data_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_GetNavDataCopy(_handle, index, ref nav_data_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            NavData nav_data = new NavData(nav_data_ptr);
            return nav_data;
        }

        /// <summary>
        /// Write the object to a file.  Note that this object is not associated with a Ping.
        /// </summary>
        /// <param name="orient">The Orientation data object to write out </param>      
        public void PutOrientation(Orientation orient)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_PutOrientation(_handle, orient.Handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the number of Orientation objects in this file.  This count does not include any Orientation objects that were written to the file as part of a Ping or a Head.
        /// </summary>
        /// <returns>number of orientation objects</returns>        
        public int OrientationCount
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int count;
                int error_code = NativeMethods.BVTSonar_GetOrientationCount(_handle, out count);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return count;
            }
        }

        /// <summary>
        /// Retrieve a Orientation object from the file.
        /// The index is zero-based, that is, if GetlOrientationCount() returned a value of 3, then valid indices are 0, 1, and 2.
        /// </summary>
        /// <param name="index">index of Orientation to return </param>
        /// <returns>The returned Orientation object</returns>      
        public Orientation GetOrientationCopy(int index)
        {
            IntPtr orient_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_GetOrientationCopy(_handle, index, ref orient_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            Orientation orient = new Orientation(orient_ptr);
            return orient;
        }

        /// <summary>
        /// Creates and writes an EventMark to the current file.
        /// The key string contains arbitrary user-defined text. The maximum length is ::BVTEVENTMARK_MAX_KEYLENGTH characters.
        /// The text string contains arbitrary user-defined text. The maximum length is ::BVTEVENTMARK_MAX_TEXTLENGTH characters.
        /// These strings provide a means to store raw data strings from various sensors such as a GPS or compass.
        /// The Key string would be used to identify the device, e.g. "GPS", and the data string ("sentence") from 
        /// the device would be stored in the Text string.
        /// Note that the EventMark is not associated with a Ping.
        /// </summary>
        /// <param name="key">null-terminated character string </param>
        /// <param name="text">null-terminated character string </param>        
        public void PutEventMark(string key, string text)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_PutEventMark(_handle, BVTSDK.InteropHelpers.StringToUtf8Ptr(key), BVTSDK.InteropHelpers.StringToUtf8Ptr(text));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns the number of EventMark objects in this file.  
        /// </summary>
        /// <returns>number of event marks </returns>       
        public int EventMarkCount
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int count;
                int error_code = NativeMethods.BVTSonar_GetEventMarkCount(_handle, out count);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return count;
            }
        }

        /// <summary>
        /// Retrieve an EventMark object from the file.
        /// The index is zero-based, that is, if EventMarkCount returned a value of 3, then valid indices are 0, 1, and 2.
        /// </summary>
        /// <param name="index">index of EventMark to return </param>
        /// <returns>The returned EventMark object</returns>        
        public EventMark GetEventMarkCopy(int index)
        {
            IntPtr em_ptr = new IntPtr();
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_GetEventMarkCopy(_handle, index, ref em_ptr);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            EventMark em = new EventMark(em_ptr);
            return em;
        }

        /// <summary>
        /// Get the network settings of this Sonar.
        /// The settings may not be valid until this Sonar is restarted.
        /// </summary>
        /// <returns>Allocated by this function.  Caller must destroy when done. </returns>     
        public NetworkSettings NetworkSettings
        {
            get
            {
                IntPtr settings_ptr = new IntPtr();
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int error_code = NativeMethods.BVTSonar_GetNetworkSettings(_handle, ref settings_ptr);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                NetworkSettings settings = new NetworkSettings(settings_ptr);
                return settings;
            }
        }

        /// <summary>
        /// Set the network settings of this sonar. 
        /// These settings will not be valid unti this Sonar is restarted.
        /// </summary>
        /// <param name="settings">The network settings to apply to this Sonar. </param>        
        public void SetNetworkSettings(NetworkSettings settings)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_SetNetworkSettings(_handle, settings.Handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Set to true to modify ping timestamps by the local computer's (running the SDK) clock.
        /// \attention Disable if this Sonar is connected to a pulse-per-second (PPS) signal.
        /// </summary>
        /// <param name="enable">True to modify ping timestamps by the local clock </param>     
        public void SetTimestampsUseLocalClock(bool enable)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_SetTimestampsUseLocalClock(_handle, (enable ? 1 : 0));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Returns true if ping timestamps are modified by the local computer's (running the SDK) clock.
        /// </summary>
        /// <returns>True if ping timestamps are modified by the local clock </returns>     
        public bool TimestampsUseLocalClock
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int is_enabled;
                int error_code = NativeMethods.BVTSonar_GetTimestampsUseLocalClock(_handle, out is_enabled);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return is_enabled > 0;
            }
        }

        /// <summary>
        /// Generates a new file containing the current configuration of the sonar. 
        /// The output should be sent to BlueView for analysis and is intended for diagnostic purposes.
        /// </summary>
        /// <param name="file">The name of the file that will contain string </param>       
        public void DumpToFile(string file)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_DumpToFile(_handle, BVTSDK.InteropHelpers.StringToUtf8Ptr(file));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Indicates whether this sonar supports target tracking.
        /// </summary>
        /// <returns>true (1) if tracking supported, false (0) otherwise</returns>      
        public bool SupportsTargetTracking
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int supported;
                int error_code = NativeMethods.BVTSonar_SupportsTargetTracking(_handle, out supported);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return supported > 0;
            }
        }

        /// <summary>
        /// Latest generation BlueView sonar support source level (transmit power) control. This calls allows users to ascertain whether the sonar supports the source level control functionality.
        /// </summary>
        /// <returns>true (1) if supported, false (0) if unsupported </returns>     
        public bool SupportsSourceLevelControl
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int supported;
                int error_code = NativeMethods.BVTSonar_SupportsSourceLevelControl(_handle, out supported);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return supported > 0;
            }
        }

        /// <summary>
        /// Set the sonar's transmit source level, only found on newer hardware. This will always disable the auto source level mode.
        /// </summary>
        /// <param name="level">Ratio of desired value to max (0.0 to 1.0) </param>     
        public void SetSourceLevel(float level)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_SetSourceLevel(_handle, level);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Get the sonar's source level (transmit power), only found on newer hardware.
        /// </summary>
        /// <returns>See SetSourceLevel </returns>      
        public float SourceLevel
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                float level;
                int error_code = NativeMethods.BVTSonar_GetSourceLevel(_handle, out level);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return level;
            }
        }

        /// <summary>
        /// Sonar that support source level control can be configured to automatically adjust the source level based on the current configured max range. This call allows users to enable/disable this feature. 
        /// </summary>
        /// <param name="enable">true (1) to enable, false (0) to disable </param>      
        public void EnableAutoSourceLevel(bool enable)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_EnableAutoSourceLevel(_handle, (enable ? 1 : 0));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Indicates whether sonar is configured to use automatic source level control.
        /// </summary>
        /// <returns>true (1) if enabled, false (0) if disabled </returns>      
        public bool IsAutoSourceLevelEnabled
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int enabled;
                int error_code = NativeMethods.BVTSonar_IsAutoSourceLevelEnabled(_handle, out enabled);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return enabled > 0;
            }
        }

        /// <summary>
        /// Return true if this sonar's hardware and firmware combination supports a hardware trigger.
        /// \warning This function will return true even if a hardware trigger is NOT physically connected to the sonar but the firmware does support triggering.
        /// \warning This function will return false even if you physically connect a hardware trigger but the firmware
        /// does not support triggering.
        /// </summary>
        /// <returns>True if this sonar's hardware and firmware combination supports a hardware trigger. </returns>     
        public bool SupportsExternalHardwareTrigger
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int supported;
                int error_code = NativeMethods.BVTSonar_SupportsExternalHardwareTrigger(_handle, out supported);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return supported > 0;
            }
        }

        /// <summary>
        /// Enables the sonar to ping on receipt of an external trigger signal. Note that 
        /// this requires a sonar equipped with a hardware trigger.
        /// \warning Enabling this option on an unsupported sonar will cause it to stop
        /// pinging until the option is turned off.
        /// \warning Enabling external triggering will override any previous setting to
        /// enable hardware trigger output. (These are mutually exclusive settings)
        /// </summary>
        /// <param name="delay">Delay in millseconds between trigger pulse and pulse transmit. </param>     
        public void EnableExternalHardwareTrigger(int delay)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_EnableExternalHardwareTrigger(_handle, delay);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Turns hardware triggering off. 
        /// </summary>      
        public void DisableExternalHardwareTrigger()
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_DisableExternalHardwareTrigger(_handle);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Enables the sonar to generate a 1 millisecond pulse on the hardware
        /// trigger line whenever the trigger event occurs. This provides a
        /// synchronization capability via hardware for multi-sensor systems. The trigger event
        /// may be specified as the beginning of acoustic transmit, the end of acoustic transmit,
        /// or the end of data acquisition.
        /// \warning Enabling hardware trigger output will override any previous 
        /// setting to enable external hardware trigger. (These are mutually exclusive settings)
        /// </summary>
        /// <param name="triggerEvent">The event in the ping cycle that will induce the trigger signal </param>     
        public void EnableExternalHardwareTriggerOutput(TriggerOutputEvent triggerEvent)
        {
            if (_disposed) throw new ObjectDisposedException("BVTSonar");
            int error_code = NativeMethods.BVTSonar_EnableExternalHardwareTriggerOutput(_handle, ((int) triggerEvent));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Queries whether hardware trigger is enabled. It is only valid for sonars equipped
        /// with a hardware trigger.
        /// </summary>
        /// <returns>On return specifies whether hardware trigger is enabled </returns>     
        public bool ExternalHardwareTriggerEnabled
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int enabled;
                int error_code = NativeMethods.BVTSonar_GetExternalHardwareTriggerEnabled(_handle, out enabled);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return enabled > 0;
            }
        }

        /// <summary>
        /// Queries the direction (input or output) of the hardware trigger. A hardware trigger
        /// configured as input indicates that the sonar pings only on receipt of a trigger pulse.
        /// A hardware trigger configured as output indicates that the sonar will emit a trigger
        /// pulse during each ping. See TriggerOutputEvent for the list of events in a ping 
        /// sequence that can be configured as the pulse trigger event. This function is only
        /// </summary>
        /// <returns>On return specifies hardware trigger direction </returns>      
        public bool ExternalHardwareTriggerDirection
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int is_input;
                int error_code = NativeMethods.BVTSonar_GetExternalHardwareTriggerDirection(_handle, out is_input);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return is_input > 0;
            }
        }

        /// <summary>
        /// Only valid if the hardware trigger is configured as an input. See EnableExternalHardwareTrigger
        /// </summary>
        /// <returns>On return specfies the hardware trigger ping delay in milliseconds</returns>       
        public int ExternalHardwareTriggerInputDelay
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int delay_in_ms;
                int error_code = NativeMethods.BVTSonar_GetExternalHardwareTriggerInputDelay(_handle, out delay_in_ms);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return delay_in_ms;
            }
        }

        /// <summary>
        /// Only valid if the hardware trigger is configure as an output. 
        /// See EnableExternalHardwareTriggerOutput
        /// </summary>
        /// <returns>On return specifies the output trigger event </returns>        
        public TriggerOutputEvent ExternalHardwareTriggerOutputEvent
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTSonar");
                int triggerEvent;
                int error_code = NativeMethods.BVTSonar_GetExternalHardwareTriggerOutputEvent(_handle, out triggerEvent);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return (TriggerOutputEvent) triggerEvent;
            }
        }


        /// SDK object pointer
        internal HandleRef Handle
        {
            get { return _handle; }
        }
        private readonly HandleRef _handle;

        private bool _disposed;

        /// P/Invoke 'wrapper' class
        private static class NativeMethods
        {
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern IntPtr BVTSonar_Create();
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern IntPtr BVTSonar_Destroy(HandleRef obj);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_Open(HandleRef obj, byte[] type, byte[] type_params);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_CreateFile(HandleRef obj, byte[] file_name, HandleRef src, byte[] create_params);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetSerialNumber(HandleRef obj, byte[] buffer, int buffer_size);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetFirmwareRevision(HandleRef obj, byte[] buffer, int buffer_size);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_IsFile(HandleRef obj, out int is_file);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_IsConnected(HandleRef obj, out int is_connected);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_SupportsMulticast(HandleRef obj, out int is_multicast);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_RevertFactorySettings(HandleRef obj);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetFileSize(HandleRef obj, out int fileSize);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetTimeIndexedPingCount(HandleRef obj, out int count);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetTimeIndexedPing(HandleRef obj, int ping_num, ref IntPtr ping);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetHead(HandleRef obj, int head_num, ref IntPtr head);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetHeadCount(HandleRef obj, out int head_count);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetSonarModelName(HandleRef obj, byte[] buffer, int buffer_size);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetSonarName(HandleRef obj, byte[] buffer, int buffer_size);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_SetSonarName(HandleRef obj, byte[] name);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetTemperature(HandleRef obj, out float temperature);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_PutNavData(HandleRef obj, HandleRef nav_data);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetNavDataCount(HandleRef obj, out int count);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetNavDataCopy(HandleRef obj, int index, ref IntPtr nav_data);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_PutOrientation(HandleRef obj, HandleRef orient);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetOrientationCount(HandleRef obj, out int count);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetOrientationCopy(HandleRef obj, int index, ref IntPtr orient);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_PutEventMark(HandleRef obj, byte[] key, byte[] text);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetEventMarkCount(HandleRef obj, out int count);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetEventMarkCopy(HandleRef obj, int index, ref IntPtr em);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetNetworkSettings(HandleRef obj, ref IntPtr settings);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_SetNetworkSettings(HandleRef obj, HandleRef settings);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_SetTimestampsUseLocalClock(HandleRef obj, int enable);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetTimestampsUseLocalClock(HandleRef obj, out int is_enabled);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_DumpToFile(HandleRef obj, byte[] file);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_SupportsTargetTracking(HandleRef obj, out int supported);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_SupportsSourceLevelControl(HandleRef obj, out int supported);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_SetSourceLevel(HandleRef obj, float level);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetSourceLevel(HandleRef obj, out float level);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_EnableAutoSourceLevel(HandleRef obj, int enable);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_IsAutoSourceLevelEnabled(HandleRef obj, out int enabled);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_SupportsExternalHardwareTrigger(HandleRef obj, out int supported);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_EnableExternalHardwareTrigger(HandleRef obj, int delay);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_DisableExternalHardwareTrigger(HandleRef obj);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_EnableExternalHardwareTriggerOutput(HandleRef obj, int triggerEvent);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetExternalHardwareTriggerEnabled(HandleRef obj, out int enabled);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetExternalHardwareTriggerDirection(HandleRef obj, out int is_input);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetExternalHardwareTriggerInputDelay(HandleRef obj, out int delay_in_ms);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTSonar_GetExternalHardwareTriggerOutputEvent(HandleRef obj, out int triggerEvent);

        }
    }

}
