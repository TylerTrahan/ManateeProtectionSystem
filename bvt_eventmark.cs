///
/// This file has been generated by bvtidl.pl. DO NOT MODIFY!
///

using System;
using System.Runtime.InteropServices;


namespace BVTSDK
{
/// <summary>
/// An EventMark allows the user to insert arbitrary information into a sonar file.  The user can
/// store two strings, one called a "Key" string and the other a "Text" string, in an EventMark. 
/// The EventMarks are stored and retrieved independently of Heads or Pings.
/// NOTE: EventMark objects will only be saved to a sonar of type FILE. 
/// </summary>
    public class EventMark : IDisposable
    {
        public EventMark()
        {
            IntPtr p = NativeMethods.BVTEventMark_Create();
            _handle = new HandleRef(this, p);
        }

        internal EventMark(IntPtr p)
        {
            _handle = new HandleRef(this, p);
        }

        /// Non-deterministic destruction of this object on the Finalizer thread
        ~EventMark()
        {
            Dispose(false);
        }

        /// Dispose deterministically
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;
            _disposed = true;
            NativeMethods.BVTEventMark_Destroy(_handle);
        }

        /// <summary>
        /// Return the timestamp in seconds since 00:00:00 UTC, January 1, 1970 
        /// The timestamp is a standard UNIX time stamp. This is 
        /// a similar value to that returned by the time() C standard library 
        /// function. In fact, the only difference is the addition of fractional seconds.
        /// </summary>
        /// <returns>timestamp of event mark </returns>     
        public double Timestamp
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTEventMark");
                double timestamp;
                int error_code = NativeMethods.BVTEventMark_GetTimestamp(_handle, out timestamp);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return timestamp;
            }
        }

        /// <summary>
        /// The max length of an EventMark key string 
        /// </summary>
        public const int MAX_KEYLENGTH = 80;

        /// <summary>
        /// Return the number of characters stored in the Key string, not including the null-term character.  You'll need to allocate a
        /// character buffer of at least length @ref KeyStringLength()+1 to retrieve the entire Key.
        /// You can also allocate a buffer of @ref MAX_KEYLENGTH at compile time.
        /// </summary>
        /// <returns>key length </returns>      
        public int KeyStringLength
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTEventMark");
                int length;
                int error_code = NativeMethods.BVTEventMark_GetKeyStringLength(_handle, out length);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return length;
            }
        }

        /// <summary>
        /// Retrieves a copy of the EventMark's Key string.
        /// </summary>
        /// <returns>buffer to hold the null-terminated string to be passed back </returns>     
        public string KeyString
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTEventMark");
                byte[] buffer = new byte[256];
                int buffer_size = 255;
                int error_code = NativeMethods.BVTEventMark_GetKeyString(_handle, buffer, buffer_size);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return BVTSDK.InteropHelpers.Utf8ToString(buffer);
            }
        }

        /// <summary>
        /// The max length of an EventMark text string 
        /// </summary>
        public const int MAX_TEXTLENGTH = 512;

        /// <summary>
        /// Return the number of characters stored in the Text string, not including the null-term character. You'll need to allocate a
        /// character buffer of at least length @ref TextStringLength()+1 to retrieve the entire string.
        /// You can also allocate a buffer of @ref MAX_TEXTLENGTH at compile time.
        /// </summary>
        /// <returns>text string length </returns>      
        public int TextStringLength
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTEventMark");
                int length;
                int error_code = NativeMethods.BVTEventMark_GetTextStringLength(_handle, out length);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return length;
            }
        }

        /// <summary>
        /// Retrieves a copy of the EventMark's Text string.
        /// </summary>
        /// <returns>buffer to hold the null-terminated string to be passed back </returns>     
        public string TextString
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTEventMark");
                byte[] buffer = new byte[256];
                int buffer_size = 255;
                int error_code = NativeMethods.BVTEventMark_GetTextString(_handle, buffer, buffer_size);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return BVTSDK.InteropHelpers.Utf8ToString(buffer);
            }
        }

        /// <summary>
        /// Return the "ping-by-time" number associated with the EventMark.
        /// This is typically the ping immediately before the EventMark was created.
        /// </summary>
        /// <returns>ping number (zero-based index)</returns>       
        public int PingNumber
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTEventMark");
                int number;
                int error_code = NativeMethods.BVTEventMark_GetPingNumber(_handle, out number);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return number;
            }
        }


        /// SDK object pointer
        internal HandleRef Handle
        {
            get { return _handle; }
        }
        private readonly HandleRef _handle;

        private bool _disposed;

        /// P/Invoke 'wrapper' class
        private static class NativeMethods
        {
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern IntPtr BVTEventMark_Create();
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern IntPtr BVTEventMark_Destroy(HandleRef obj);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTEventMark_GetTimestamp(HandleRef obj, out double timestamp);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTEventMark_GetKeyStringLength(HandleRef obj, out int length);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTEventMark_GetKeyString(HandleRef obj, byte[] buffer, int buffer_size);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTEventMark_GetTextStringLength(HandleRef obj, out int length);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTEventMark_GetTextString(HandleRef obj, byte[] buffer, int buffer_size);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTEventMark_GetPingNumber(HandleRef obj, out int number);

        }
    }

}
