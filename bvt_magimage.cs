///
/// This file has been generated by bvtidl.pl. DO NOT MODIFY!
///

using System;
using System.Runtime.InteropServices;


namespace BVTSDK
{
/// <summary>
/// MagImage is short for MagnitudeImage.  It provides access to a 2d 
/// image where each pixel is intensity of the return from a particular
/// point on a plane emanating from the head.  It can be thought of as 
/// a 16bit grey-scale image.
/// </summary>
    public class MagImage : IDisposable
    {

        internal MagImage(IntPtr p)
        {
            _handle = new HandleRef(this, p);
        }

        /// Non-deterministic destruction of this object on the Finalizer thread
        ~MagImage()
        {
            Dispose(false);
        }

        /// Dispose deterministically
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;
            _disposed = true;
            NativeMethods.BVTMagImage_Destroy(_handle);
        }

        /// <summary>
        /// Return the value of the pixel at (row, col)
        /// </summary>
        /// <param name="row">Requested row </param>
        /// <param name="col">Requested col </param>
        /// <returns>Value of the pixel at (row, col) </returns>        
        public UInt16 GetPixel(int row, int col)
        {
            if (_disposed) throw new ObjectDisposedException("BVTMagImage");
            UInt16 pixel;
            int error_code = NativeMethods.BVTMagImage_GetPixel(_handle, row, col, out pixel);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            return pixel;
        }

        /// <summary>
        /// Return a pointer to a row of pixels 
        /// </summary>
        /// <param name="row">Requested row index </param>
        /// <returns>pointer to pointer to row</returns>        
        public UInt16 GetRow(int row)
        {
            if (_disposed) throw new ObjectDisposedException("BVTMagImage");
            UInt16 rowPointer;
            int error_code = NativeMethods.BVTMagImage_GetRow(_handle, row, out rowPointer);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            return rowPointer;
        }

        /// <summary>
        /// Return a pointer to the entire image.
        /// The image or organized in Row-Major order (just like C/C++).
        /// </summary>
        /// <returns>pointer to pointer to image </returns>     
        public UInt16 Bits
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTMagImage");
                UInt16 bitsPointer;
                int error_code = NativeMethods.BVTMagImage_GetBits(_handle, out bitsPointer);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return bitsPointer;
            }
        }

        /// <summary>
        /// Copy the raw image data to the user specified buffer. See Bits for more info.
        /// </summary>
        /// <param name="data">Pointer to a valid buffer </param>
        /// <param name="len">The size of the buffer pointed to by data in pixels NOT bytes. </param>       
        public void CopyBits(UInt16[] data, UInt32 len)
        {
            if (_disposed) throw new ObjectDisposedException("BVTMagImage");
            int error_code = NativeMethods.BVTMagImage_CopyBits(_handle, data, len);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Save the image in PGM (PortableGreyMap) format. http://en.wikipedia.org/wiki/Netpbm_format
        /// Note that few programs actually support loading a 16bit PGM. 
        /// A good image viewer for Windows is Irfanview: http://www.irfanview.com/ 
        /// Once you load a PGM, you will most likely need to tone map it or the majority of the image will appear black.
        /// </summary>
        /// <param name="file_name">File name to save to </param>       
        public void SavePGM(string file_name)
        {
            if (_disposed) throw new ObjectDisposedException("BVTMagImage");
            int error_code = NativeMethods.BVTMagImage_SavePGM(_handle, BVTSDK.InteropHelpers.StringToUtf8Ptr(file_name));
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the height (in pixels) of this image
        /// </summary>
        /// <returns>image height</returns>     
        public int Height
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTMagImage");
                int height;
                int error_code = NativeMethods.BVTMagImage_GetHeight(_handle, out height);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return height;
            }
        }

        /// <summary>
        /// Return the width (in pixels) of this image
        /// </summary>
        /// <returns>image width</returns>      
        public int Width
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTMagImage");
                int width;
                int error_code = NativeMethods.BVTMagImage_GetWidth(_handle, out width);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return width;
            }
        }

        /// <summary>
        /// Return the max range (in meters) to a non-blank pixel in the image
        /// </summary>
        /// <returns>max range to a non-blank pixel in the image</returns>      
        public float MaxRangeOfPixel
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTMagImage");
                float maxRange;
                int error_code = NativeMethods.BVTMagImage_GetMaxRangeOfPixel(_handle, out maxRange);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return maxRange;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Image type constant (IMAGETYPE_*) </returns>       
        public ImageType ImageType
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTMagImage");
                int type;
                int error_code = NativeMethods.BVTMagImage_GetImageType(_handle, out type);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return (ImageType) type;
            }
        }

        /// <summary>
        /// Return the range resolution of this image.
        /// The resolution is returned in meters per pixel row.
        /// </summary>
        /// <returns>image range resolution</returns>       
        public double RangeResolution
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTMagImage");
                double resolution;
                int error_code = NativeMethods.BVTMagImage_GetRangeResolution(_handle, out resolution);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return resolution;
            }
        }

        /// <summary>
        /// Only valid for R-Theta images.
        /// Returns the bearing resolution, in degrees per pixel column.
        /// </summary>
        /// <returns>image bearing resolution</returns>     
        public double BearingResolution
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTMagImage");
                double resolution;
                int error_code = NativeMethods.BVTMagImage_GetBearingResolution(_handle, out resolution);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return resolution;
            }
        }

        /// <summary>
        /// Retrieve the image row of the origin.
        /// In most cases the origin row will be outside of the image boundaries (i.e., negative). The origin is the 'location' (in pixels) of the sonar head in image plane.
        /// </summary>
        /// <returns>pixel row</returns>        
        public int OriginRow
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTMagImage");
                int row;
                int error_code = NativeMethods.BVTMagImage_GetOriginRow(_handle, out row);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return row;
            }
        }

        /// <summary>
        /// Retrieve the image column of the origin.
        /// The origin is the 'location' (in pixels) of the
        /// sonar head in image plane.
        /// </summary>
        /// <returns>pixel column</returns>     
        public int OriginCol
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTMagImage");
                int column;
                int error_code = NativeMethods.BVTMagImage_GetOriginCol(_handle, out column);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return column;
            }
        }

        /// <summary>
        /// Retrieve the range (from the sonar head) of the specified pixel (in meters)
        /// </summary>
        /// <param name="row">pixel row </param>
        /// <param name="col">pixel col </param>
        /// <returns>range to given pixel </returns>        
        public double GetPixelRange(int row, int col)
        {
            if (_disposed) throw new ObjectDisposedException("BVTMagImage");
            double range;
            int error_code = NativeMethods.BVTMagImage_GetPixelRange(_handle, row, col, out range);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            return range;
        }

        /// <summary>
        /// Retrieve the bearing relative to the sonar head of the specified pixel
        /// </summary>
        /// <param name="row">pixel row </param>
        /// <param name="col">pixel col </param>
        /// <returns>bearing to given pixel </returns>      
        public double GetPixelRelativeBearing(int row, int col)
        {
            if (_disposed) throw new ObjectDisposedException("BVTMagImage");
            double bearing;
            int error_code = NativeMethods.BVTMagImage_GetPixelRelativeBearing(_handle, row, col, out bearing);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
            return bearing;
        }

        /// <summary>
        /// Return the pixel coordinate at the specified physical location.
        /// The returned coordinate may be outside this image's bounds.
        /// </summary>
        /// <param name="range">range in meters </param>
        /// <param name="bearing">bearing in radians </param>
        /// <param name="x">pixel index in the X-axis </param>
        /// <param name="y">pixel index in the Y-axis </param>      
        public void GetPixelCoordinateAtRangeBearing(float range, float bearing, out int x, out int y)
        {
            if (_disposed) throw new ObjectDisposedException("BVTMagImage");
            int error_code = NativeMethods.BVTMagImage_GetPixelCoordinateAtRangeBearing(_handle, range, bearing, out x, out y);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the pixel coordinate at the specified physical location in the sonar's frame.
        /// The returned coordinate may be outside this image's bounds.
        /// </summary>
        /// <param name="x_meters">X distance in meters </param>
        /// <param name="y_meters">Y distance in meters </param>
        /// <param name="x">pixel index in the X-axis </param>
        /// <param name="y">pixel index in the Y-axis </param>      
        public void GetPixelCoordinateAtXY(float x_meters, float y_meters, out int x, out int y)
        {
            if (_disposed) throw new ObjectDisposedException("BVTMagImage");
            int error_code = NativeMethods.BVTMagImage_GetPixelCoordinateAtXY(_handle, x_meters, y_meters, out x, out y);
            GC.KeepAlive(this);
            if (0 != error_code)
                throw new SdkException(error_code);
        }

        /// <summary>
        /// Return the minimum angle for the sonar's imaging field of view. 
        /// The angle is returned in degrees and referenced with respect to sonar head boresight (clockwise-positive).
        /// </summary>
        /// <returns>min. angle</returns>       
        public float FOVMinAngle
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTMagImage");
                float angle;
                int error_code = NativeMethods.BVTMagImage_GetFOVMinAngle(_handle, out angle);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return angle;
            }
        }

        /// <summary>
        /// Return the maximum angle for the sonar's imaging field of view. 
        /// The angle is returned in degrees and referenced with respect to sonar head boresight (clockwise-positive).
        /// </summary>
        /// <returns>max. angle</returns>       
        public float FOVMaxAngle
        {
            get
            {
                if (_disposed) throw new ObjectDisposedException("BVTMagImage");
                float angle;
                int error_code = NativeMethods.BVTMagImage_GetFOVMaxAngle(_handle, out angle);
                GC.KeepAlive(this);
                if (0 != error_code)
                    throw new SdkException(error_code);
                return angle;
            }
        }


        /// SDK object pointer
        internal HandleRef Handle
        {
            get { return _handle; }
        }
        private readonly HandleRef _handle;

        private bool _disposed;

        /// P/Invoke 'wrapper' class
        private static class NativeMethods
        {
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern IntPtr BVTMagImage_Destroy(HandleRef obj);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetPixel(HandleRef obj, int row, int col, out UInt16 pixel);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetRow(HandleRef obj, int row, out UInt16 rowPointer);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetBits(HandleRef obj, out UInt16 bitsPointer);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_CopyBits(HandleRef obj, UInt16[] data, UInt32 len);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_SavePGM(HandleRef obj, byte[] file_name);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetHeight(HandleRef obj, out int height);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetWidth(HandleRef obj, out int width);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetMaxRangeOfPixel(HandleRef obj, out float maxRange);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetImageType(HandleRef obj, out int type);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetRangeResolution(HandleRef obj, out double resolution);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetBearingResolution(HandleRef obj, out double resolution);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetOriginRow(HandleRef obj, out int row);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetOriginCol(HandleRef obj, out int column);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetPixelRange(HandleRef obj, int row, int col, out double range);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetPixelRelativeBearing(HandleRef obj, int row, int col, out double bearing);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetPixelCoordinateAtRangeBearing(HandleRef obj, float range, float bearing, out int x, out int y);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetPixelCoordinateAtXY(HandleRef obj, float x_meters, float y_meters, out int x, out int y);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetFOVMinAngle(HandleRef obj, out float angle);
            [DllImport("bvtsdk4", CallingConvention=CallingConvention.Cdecl)]
            public static extern int BVTMagImage_GetFOVMaxAngle(HandleRef obj, out float angle);

        }
    }

}
